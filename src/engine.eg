

require:
   opg ->
      Source
   .lang ->
      parse
   .ast ->
      QAst, Text, Oper, Seq
      Into, Deferred
   .etools
   .tools as tools ->
      makeExtractor
      normalize
      may-fail
   .doc ->
      SeqDocument
   .util ->
      insertSorted
      transform
   "./html" ->
      HTMLFormatter
   /html
   /dom
   fs

provide:
   Dispatcher
   Engine
   Spec
   processDocuments

class Dispatcher:

   constructor{} =
      @dispatch = {}

   gen handlers{node} =
      key = node.operator or ""
      if not key:
         console.error with
            "Node lacks an operator key. That may be indicative of a bug."
      match @dispatch[key]:
         undefined? ->
            false
         candidates ->
            candidates each c ->
               match node:
                  c! parts ->
                     yield {parts, c}
                  else ->
                     pass
            false

   register{*match} =
      {Spec? handler} ->
         key = handler.operator
         l = [@dispatch[key] or= {}]
         insertSorted{l, handler} with
            {{specificity => match s1}, {specificity => s2}} ->
               ;; Do not return 0 because it will cause a replacement
               > s2 -> -1
               else -> 1
      {rule, fn} ->
         @register{Spec{rule, fn}}

   clone{} =
      d = Dispatcher{}
      d.dispatch = object with items{@dispatch} each {key, l} ->
         {key, l.slice{0}}
      d


class Engine:

   constructor{Array! plugins} =
      @next = tools.next
      @top = true
      @is-quaint-engine = true
      @components = {=}
      @dispatch = Dispatcher{}
      @documents = {=}
      @formatters = {
         html = HTMLFormatter{@}
      }
      @regexps = {}
      @methods = {}
      @macros = {=}
      @resolvers = {=}
      @resources = {=}
      @plug{*plugins}
      @tools = tools
      @etools = etools
      @template = null
      @deferred = Deferred
      @into = Into

   fork-plug{*plugins} =
      @fork{}.plug{*plugins}

   plug{*plugins} =
      plugins each match plugin ->
         Function? f -> f{@}
         {=> install-to} ->
            plugin.install-to{@}
      @


   .gen{match node} =
      
      Text? {t} or Oper? {t} ->
         l = node.location
         r = R.g"~|\\[\\~!@#$%^&*_\-+=<>/?;:.`|(){}\[\],.]"
         node.location.text{}.replace{r} with {match} ->
            "~" -> ""
            s -> s[1]

      Seq? {*parts} ->
         result = f{} where f{} =
            @dispatch.handlers{node} each {values, handler} ->
               extra = {_node = node
                        _wide = node.width == .wide
                        _op = node[1]}
               x = may-fail{-> handler.gen{@, extra & values}}
               match x:
                  == @next -> pass
                  undefined? -> return ""
                  else -> return x
            % [parts each part -> @gen{part}]
         result

      null? or undefined? ->
         ""

      x and [ENode? or Array? or String? or Boolean?] ->
         x

      Error? e ->
         if e.id as id:
            div.error %
               id = 'ERR{id}'
               '[#{id}] '
               e.stack
         else:
            div.error % e.stack

   gen-from-source{match src} =
      String? text ->
         @gen-from-source{Source{text, "<quaint>"}}
      Source? src ->
         parsed = parse{src}
         @gen{parsed}
      node ->
         @gen{node}

   run{src} =
      generated = @gen-from-source{src}
      docs = @documents
      main = processDocuments{generated, docs}
      docs &: {= main}

   ;; translate{src, format, options = {=}} =

   ;;    ;; stash = {}

   ;;    ;; crossReplace{children, regexps, ndone = 0} =
   ;;    ;;    if regexps 
   ;;    ;;    s = xs.join{""} where xs = children each
   ;;    ;;       String? s -> s
   ;;    ;;       other ->
   ;;    ;;          stash.push with other
   ;;    ;;          S'#{stash.length - 1}#'

   ;;    finalize{match, ndone} =
   ;;       var String? s ->
   ;;          enumerate{@regexps.slice{ndone}} each {i, {r, match repl}} ->
   ;;             String? ->
   ;;                s = s.replace{r, repl}
   ;;             Function? f or f is [-> repl] ->
   ;;                s = s.replace{r, repl}
   ;;                ;; parts = {}
   ;;                ;; var index = 0
   ;;                ;; var curr = null
   ;;                ;; while [curr = r.exec{s}]:
   ;;                ;;    parts.push{s[index...curr.index]}
   ;;                ;;    index = curr.index + curr[0].length
   ;;                ;;    parts.push{f{*curr}}
   ;;                ;;    if not "g" in r.flags:
   ;;                ;;       break
   ;;                ;; parts.push{s.slice{index}}
   ;;                ;; return collapse{parts, ndone + i + 1}
   ;;          s
   ;;       x -> x

   ;;    collapse{x} =
   ;;       etools.merge-children{x, true, {x} -> finalize{x, 0}}

   ;;    results = @run{src}

   ;;    main = normalize{collapse{top}} where top =
   ;;       if options.paragraph:
   ;;          p % results.main
   ;;       else:
   ;;          top % results.main

   ;;    result = match format:
   ;;       .enode -> main
   ;;       .text -> main.toString{}
   ;;       ;; .html -> html{main}
   ;;       .html ->
   ;;          {x, files} = @formatters.html.format{main, @resources, options}
   ;;          x
   ;;       .dom -> dom{main}

   ;;    if @template and not options.no-template:
   ;;       ;; r = @resolvers.template or @resolvers.default
   ;;       ;; if not r:
   ;;       ;;    throw E.template.no-resolver{'Cannot resolve templates.'}
   ;;       tsrc =
   ;;          ;; match r{@template}:
   ;;          match @read-resource{.template, @template}:
   ;;             {=> file, => contents} -> Source{contents, file}
   ;;             {=> contents} or String? contents -> Source{contents, "<quaint>"}
   ;;       @template = null
   ;;       @setenv{.body, raw % result}
   ;;       @translate{tsrc, format, options}
   ;;    else:
   ;;       result

   translate{src, format, options = {=}} =
      finalize{match, ndone} =
         var String? s ->
            enumerate{@regexps.slice{ndone}} each {i, {r, match repl}} ->
               String? ->
                  s = s.replace{r, repl}
               Function? f or f is [-> repl] ->
                  inserts = {""}
                  f2{*args} =
                     match f{*args}:
                        String? s -> s
                        other ->
                           inserts.push{other}
                           "\x00"
                  s = s.replace{r, f2}
                  if inserts.length > 1:
                     return collapse{zip{inserts, s.split{"\x00"}}}
                  else:
                     s
            s
         x -> x

      collapse{x} =
         etools.merge-children{x, true, {x} -> finalize{x, 0}}

      results = @run{src}

      main = normalize{collapse{top}} where top =
         if options.paragraph:
            p % results.main
         else:
            top % results.main

      {result, files} = match format:
         .enode ->
            {main, {=}}
         .text ->
            {main.toString{}, {=}}
         .html ->
            @formatters.html.format{main, @resources, options.resources}
         .dom ->
            {dom{main}, {=}}

      if @template and not options.no-template:
         tsrc =
            match @read-resource{.template, @template}:
               {=> file, => contents} -> Source{contents, file}
               {=> contents} or String? contents -> Source{contents, "<quaint>"}
         @template = null
         @setenv{.body, raw % result}
         {contents => r2, files => f2} = @translate{tsrc, format, options}
         {contents = r2, files = files & f2}
      else:
         {contents = result, files = files}

   toHTML{src, options = {=}} =
      @translate{src, .html, options}.contents

   toENode{src, options = {=}} =
      @translate{src, .enode, options}.contents


   write{path, src, type, options = {=}} =
      w = options.write or fs.write-file-sync
      {=> contents, => files} = @translate{src, type, options}
      w{path, contents}
      items{files} each {path, contents} ->
         w{path, contents}

   writeHTML{path, src, options = {=}} =
      @write{path, src, .html, options}


   register-components{cmps} =
      @components &: cmps

   register-document{*args} =
      console.error{'Deprecated: Engine::registerDocument, use Engine::registerDocuments'}
      @registerDocuments.apply{@, args}

   register-documents{docs} =
      items{docs} each {name, maker} ->
         @documents[name] = maker
      @

   register-methods{methods} =
      @methods ++= keys{methods}
      this &: methods
      @

   register-macros{macs} =
      @macros &: macs
      @

   register-postprocessor{*match} =
      {match expr, repl} ->
         String? ->
            @regexps.push{{RegExp{expr, "g"}, repl}}
            @
         RegExp? ->
            @regexps.push{{expr, repl}}
            @
      {each {expr, repl}} ->
         @register-substitutions{expr, repl}
         @

   register-resolvers{resolvers} =
      items{resolvers} each {name, res} ->
         @resolvers[name] or= {
            fns = {}
            keys = {=}
         }
         match res:
            Function? -> @resolvers[name].fns.unshift{res}
            else      -> @resolvers[name].keys &: res
         ;; @resolvers[name] or= {}
         ;; @resolvers[name].push{res}
      @

   register-resources{resources} =
      items{resources} each {name, data} ->
         if data.path and not data.path-is-url and not data.full-path:
            {=> path} = @read-resource{.resource, data.path, {read = false}}
            data.full-path = path

         ;; if data.path and data.contents === true:
         ;;    data.contents = @read-resource-contents{.resource, data.path}

         ;; if @resources[name] as prev:
         ;;    if prev.contents !== data.contents:
         ;;       throw E.quaint.resource with
         ;;          'Duplicate resource "{name}" has inconsistent content.'

         @resources[name] = data

   register-rule{*args} =
      console.error{'Deprecated: Engine::registerRule, use Engine::registerRules'}
      @register-rules.apply{@, args}

   register-rules{*match} =
      {rule, handler} ->
         @dispatch.register{rule, handler}
         @
      {rules} ->
         items{rules} each {name, match} ->
            Function? handler ->
               @dispatch.register{name, handler}
            {rule, handler} ->
               @dispatch.register{rule, handler}
         @

   clear-rules{} =
      @dispatch = Dispatcher{}
      @

   read-resource{type, filename, var options} =
      options = {fallback-to-default = true, read = true} & options
      resolver = @resolvers[type]
      var error = null

      if not resolver:
         if options.fallback-to-default and type !== "default":
            return @read-resource{.default, filename, options}
         else:
            throw E.cannot-resolve-type{'Resource "{filename}" of type "{type}" cannot be resolved.'}

      match resolver.keys[filename] as result:
         undefined? ->
            resolver.fns each fn ->
               try:
                  return fn{filename, options}
               catch e:
                  error = e
            if error:
               throw error
            elif options.fallback-to-default:
               @read-resource{.default, filename, options}
            else:
               throw E.cannot-resolve{'Resource "{filename}" could not be resolved.'}

         else ->
            result

      ;; to-try = [@resolvers[type] or {}] ++
      ;;    if{options.fallback-to-default, @resolvers.default, {}}
      ;; var error = null
      ;; to-try each resolver ->
      ;;    try:
      ;;       return resolver{filename}
      ;;    catch e:
      ;;       error = e
      ;; if error:
      ;;    throw error
      ;; else:
      ;;    throw E.cannot-resolve-type{'Resources of type "{type}" cannot be resolved.'}

   read-resource-contents{type, filename, options} =
      match @read-resource{type, filename, options}:
         {=> contents} -> contents
         contents -> contents

      ;; resolver =
      ;;    @resolvers[type] or
      ;;       if{options.fallback-to-default, @resolvers.default, null}
      ;; if not resolver:
      ;;    throw E.cannot-resolve-type{'Resources of type "{type}" cannot be resolved.'}
      ;; resolver{filename}

   read-resource-text{type, filename, options} =
      match @read-resource{type, filename, options}:
         {=> contents} -> contents
         contents -> contents

   fork{} =
      e = Engine{{}}
      e.top = false
      e.dispatch = @dispatch.clone{}
      e.components = @components
      e.documents = @documents
      e.evaluator = @evaluator.fork{}
      e.formatters = clone{@formatters}
      e.regexps = clone{@regexps}
      e.macros = clone{@macros}
      e.methods = clone{@methods}
      e.methods each m -> e[m] = this[m]
      e.resolvers = clone{@resolvers}
      e.resources = @resources
      e.template = @template
      e


   eval{text, env, loc = null} =
      @evaluator.eval{text, env, loc}

   setenv{*match} =
      {name, value} ->
         @evaluator.setenv{name, value}
         @
      {env} ->
         items{env} each {k, v} ->
            @setenv{k, v}
         @


   redefer{match node, fn} =
      Deferred? ->
         Deferred with {path, docs} ->
            res =
               try:
                  node.generate{path, docs}
               catch e:
                  e
            @redefer{res, fn}
      else ->
         fn{node}


class Spec:
   constructor{makeExtractor! {@operator, @specificity, @extractor}, @gen} =
      pass
   [^Symbol.project-no-exc]{@extractor! match} =
      false? ->
         {false, null}
      values ->
         {true, values}



processDocuments{x, documents, maxiter = 10} =

   var forges = new Set{}
   deps = new Map{}

   populate{match node, documents, replace, path} =

      [redoc %]? ->
         {child} = node.children
         populate{child, newdocs, replace, path} where newdocs =
            match node.props.documents:
               Function? f -> f{documents}
               docs -> documents & docs

      Into? ->
         docname = node.document
         match documents[docname]:
            undefined? when node.create ->
               documents[docname] = node.create{}
            undefined? when node.important ->
               throw E.no_document{docname}
            else ->
               pass

         match documents[docname]:
            false? ->
               ""
            {delay => true?} ->
               node
            doc ->
               ;; doc.register.apply{doc, {path} ++ node.children}
               doc.register.call{doc, path, node.value}
               ""

      Deferred? ->
         forges.add{{node, documents, replace, path}}
         "PLACEHOLDER"

      ENode? ->
         rval = etools.inherit{node, tags, props, children} where
            tags = node.tags
            props = object with items{node.props} each {k, match v} ->
               _ -> {k, populate{v, documents, replace, path ++ {k}}} where
                  replace{x} = rval.props[k] = x
            children =
               enumerate{node.children} each {i, c} ->
                  populate{c, documents, replace, path ++ {i}} where
                     replace{x} = rval.children[i] = x
         rval

      Array? ->
         rval =
            enumerate{node} each {i, c} ->
               populate{c, documents, replace, path ++ {i}} where
                  replace{x} = rval[i] = x
         rval

      else ->
         node

   var res = populate{% {x}, documents, replace, {}} where
      replace{x} = res = x

   var niter = 0
   while forges.size != 0 and niter < maxiter:

      {_forges, forges} = {forges, new Set{}}
      niter += 1

      _forges each forge and {node, docs, replace, path} ->

         ;; Reset accessed/modified flags for all documents
         items{docs} each {_, doc} when doc.resetFlags ->
            doc.resetFlags{}

         ;; Execute generator, process new node, perform the replacement.
         replace with populate{newnode, docs, replace, path} where
            newnode = may-fail{-> node.generate{path, docs}}

         ;; For all modified documents, every process that accessed
         ;; them is put back in the queue for reprocessing
         items{docs} each {_, doc} when doc.modified ->
            [deps.get{doc} or {}] each
               forge -> forges.add{forge}
            deps.set{doc, {}}

         ;; For all documents it accessed, the current generator is
         ;; put in the dependencies for that document. Since we do this
         ;; after checking for modifications, a generator may modify
         ;; a document it accesses without causing an infinite loop.
         items{docs} each {_, doc} when doc.accessed ->
            if not deps.has{doc}: deps.set{doc, {}}
            deps.get{doc}.push with forge

   res.children[0]

