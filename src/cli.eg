
require:
   yargs
   .run
   deepmerge
   .run2 -> main
   engage
   path
   child_process

get-arguments{} =

   argv = chain yargs:
      @usage{"Usage: quaint <file ...> [options]"}

      ;; --config, -c
      @alias{.c, .config}
      @nargs{.c, 1}
      @default{.c, "./quaint.json"}
      @describe{.c, "Path to a configuration file with option values (must be JSON)"}

      ;; --data, -d
      @alias{.d, .data}
      @nargs{.d, 1}
      @describe{.d} with """
         JSON string or file(s) defining field:value pairs to be made available inside markup (as {field}):
         * key:value
         * {"key": value, ...}
         * filename.json
         * prefix::filename.json
      """.trim{}

      ;; --eval, -e
      @alias{.e, .eval}
      @nargs{.e, 1}
      @describe{.e, "Quaint string to parse directly"}

      ;; --format, -f
      @alias{.f, .format}
      @nargs{.f, 1}
      @describe{.f, "Format (only html currently supported)"}

      ;; --help, -h
      @alias{.h, .help}
      @help{.h}

      ;; --inline
      @describe{.inline, "Inline resources in the HTML"}

      ;; --out, -o
      @alias{.o, .out}
      @nargs{.o, 1}
      @describe{.o, "File or directory to save the output to"}

      ;; --plugin, -p
      @alias{.p, .plugin}
      @nargs{.p, 1}
      @describe{.p, """Plugin(s) to import:
         * Quaint file (injected at the beginning)
         * Path to JavaScript file
         * Local npm module
         * Global npm module"""}

      ;; --resources, -r
      @alias{.r, .resources}
      @describe{.r, "Directory where to put the resources"}

      ;; --resources-url
      @describe{"resources-url", "URL for the resources directory"}

      ;; --serve
      @default{.serve, false}
      @describe{.serve, "Start server on specified port, in output directory"}

      ;; --stdout, -s
      @alias{.s, .stdout}
      @boolean{.s}
      @default{.s, false}
      @describe{.s, "Print to standard out"}

      ;; --template, -t
      @alias{.t, .template}
      @nargs{.t, 1}
      @describe{.t, "Quaint file to use as template, or template directory"}

      ;; --verbose, -v
      @alias{.v, .verbose}
      @boolean{.v}
      @describe{.v, "Print information about the operations performed"}

      ;; --save-meta
      @default{"save-meta", false}
      @describe{"save-meta", "Save meta data in a file (./meta.json if the file is not specified)"}

      ;; --watch, -w
      @alias{.w, .watch}
      @default{"watch", false}
      @describe{"watch", "Watch for changes to rebuild"}

      ;; TODO

      ;; ;; --save-config
      ;; @default{"save-config", false}
      ;; @describe{"save-config", "Save the given options in a JSON file (./quaint.json if the file is not specified)"}

      ;; ;; --dump-data
      ;; @default{"dump-data", true}
      ;; @describe{"dump-data", "Dump data provided with -d in a file (./data.json if the file is not specified)"}

      @example with
         "quaint myfile.q"
         "Translate to myfile.html"
      @example with
         "quaint file1.q file2.q file3.q -v"
         "Translate multiple files"
      @example with
         "quaint -e 'Quaint is __cool'"
         "Translate a literal"

      @example with
         "quaint -e 'Play {game}' -d 'game:chess'"
         "Fill data in"
      @example with
         "quaint article.q -d info.json"
         "Fill data in from a file"

      @example with
         "quaint -e '2+2={2+2}' -p javascript"
         "Using the quaint-javascript plugin"
      @example with
         "quaint file1.q file2.q -p prelude.q"
         "Prepend prelude to each file"

      @example with
         "quaint file.q -t tpl"
         "Use template ./tpl.q"
      @example with
         "quaint -e 'B' -t 'A {body} C'"
         "Inline template, prints out A B C"
      @example with
         "quaint -e '[template::tpl]BODY'"
         "Use template ./tpl.q"
      @example with
         "quaint -e '[template::tpl]BODY' -t templates/"
         "Use template ./templates/tpl.q"

      @check with {argv} ->
         ;; if not argv.e and not argv._.length:
         ;;    throw E.usage with
         ;;       "You must provide one or more filenames, or a string with the -e option."
         if argv.e and argv._.length:
            throw E.usage with
               "You cannot translate a file if the -e option is used."
         if argv.s and argv.o:
            throw E.usage with
               "You cannot combine the options -s and -o."
         true

      @argv


cli-error{msg, fn} =
   try:
      fn{}
   catch e:
      throw E.cli-error{msg, e}

defaults{} = {
   sources = {}
   data-files = {}
   data = {=}
   plugins = {=}
   injections = {}
   output = "."
   format = "html"
   templates = {
      default = "@minimal"
      ;; override = null
      root = null
   }
   resources = {
      root = "."
      inline = false
   }
   save-meta = false
   watch = false
   server = {
      enable = false
      delay = 300
      port = 8080
      start-page = "index.html"
      open-browser = true
   }
   verbose = false
}

normalize-config{_cfg} =
   rval = deepmerge{defaults{}, _cfg}
   ;; print rval
   ;; print defaults{}
   ;; print _cfg
   rval.plugins =
      match rval.plugins:
         String? s -> {s => true}
         obj -> obj
   {.sources, .data-files, .injections} each name ->
      rval[name] = Array! rval[name]
   rval


json-filename{match f} =
   R"\."? -> f
   else -> f + ".json"

json-parse{filename, contents} =
   cli-error{'Error parsing JSON in {filename}'} with ->
      JSON.parse{contents}

merge-config{normalize-config! cfg, argv} =
   ;; sources
   cfg.sources ++= argv._

   ;; data
   cfg as {=> data, => data-files}
   [Array! [argv.data or {}]] each match entry ->
      undefined? -> pass
      R"^[\"']"? ->
         data &: json-parse{'argument {entry}', "{" + entry + "}"}
      R"^[{]"? ->
         data &: json-parse{'argument {entry}', entry}
      R"([a-zA-Z0-9_.-]+)::(.*)"! {_, key, filename} ->
         data-files.push with {key => json-filename{filename}}
      R"([a-zA-Z0-9_-]+):(.*)"! {_, key, value} ->
         try:
            data &: {key => JSON.parse{value}}
         catch e:
            data &: {key => value}
      filename ->
         data-files.push with json-filename{filename}

   ;; plugins
   var {=> plugins, => injections} = cfg

   resolve-string{match name, arg = {=}} =
      R"^([^()]+)\((.*)\)$"! {_, n, arg} ->
         resolve-string{n, JSON.parse{arg}}
      R"^([^{}]+)(\{.*\})$"! {_, n, arg} ->
         resolve-string{n, JSON.parse{arg}}
      R"^(\.+)([^/.]|$)"! {_, dots, _} ->
         resolve-string{dots + "/" + name.slice{dots.length}, arg}
      R"\.q$"? ->
         injections.push with name
      else ->
         plugins = deepmerge{plugins} with {name => arg}

   [Array! [argv.plugin or {}]] each s -> resolve-string{s}
   cfg.plugins = plugins
   cfg.injections = injections

   ;; others
   {.format, .save-meta, .out, .eval, .verbose} each name ->
      if argv[name] as x:
         cfg[name] = x
   if argv.resources as [let x]:
      cfg.resources.root = x
   if argv.resources-url as [let x]:
      cfg.resources.url = x
   if argv.inline as [let x]:
      cfg.resources.inline = x
   if argv.serve as [let x]:
      if x:
         cfg.server.enable = true
         cfg.server.port = if{x === true, 8080, Number{x}}

   ;; Starting the server implies watch
   if cfg.server.enable:
      cfg.watch = true

   ;; misc
   cfg.resources.url or= cfg.resources.root
   if cfg.save-meta === true:
      cfg.save-meta = "meta.json"

   cfg


reload-bin-path = path.join{__dirname, '../node_modules/reload/bin/reload'}

provide{} =
   try:
      argv = get-arguments{}

      require: fs
      cfg = merge-config with
         JSON.parse{fs.read-file-sync{"quaint.json", .utf8}}
         argv

      ;; if cfg.server.enable:
      ;;    serve{cfg.output, cfg.server}

      engage{main, opts}.run{} where opts = {
         config = cfg
         paths = {
            root = "."
            content = "."
            output = cfg.output
         }
         show = {
            read = false
            write = false
            task = cfg.verbose
         }
         ignore-empty-changes = true
         watch = cfg.watch
      }

      if cfg.server.enable:
         child_process.spawn{reload-bin-path} with
            {
               "-d", cfg.output
               "-p", cfg.server.port
               "-r", cfg.server.delay
               "-s", cfg.server.start-page
               "-b", cfg.server.open-browser
            }
            {stdio = .inherit}

      ;; run{get-arguments{}}
   catch [E.usage-error? e]:
      yargs.show-help{}
      console.error{e.message}
      process.exit{1}
   catch [E.cli-error? e]:
      console.error with e.message
      if Error? e[0]:
         console.error with '\n{e[0].stack}'
   catch e:
      console.error with e.stack

