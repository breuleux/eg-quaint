
require:
   ..tools ->
      raw, shed, extractor, statements, toJSON, to-data
   ..ast ->
      Into, Deferred
   ..doc ->
      SeqDocument, MapDocument

provide:
   install

install{@} =

   @register-documents with {
      meta = MapDocument{}
   }

   @register-macros with {

      store{engine, shed! raw! name, body} =
         if raw{body} == "dump!":
            engine.macros.dump{engine, name}
         else:
            Into{name, body, create{} = SeqDocument{}}

      dump{engine, shed! raw! name} =
         Deferred with {path, docs} ->
            match docs[name]:
               undefined? ->
                  ""
               doc ->
                  if name !== "flags":
                     docs.flags.set{'{name}$dumped', true}
                  doc.entries{} each x -> engine.gen{x}

      meta{engine, body} =
         r = raw{body}
         if r == "dump!":
            Deferred with {path, docs} ->
               table % docs.meta.entries{} each
                  {k, v} -> tr %
                     td % k
                     td % engine.gen{v}
         elif R"[=:]"? raw{body}:

            leaf{x} =
               match x.raw{}:
                  "true" -> true
                  "false" -> false
                  R"^\"\"$"? s -> JSON.parse{s}
                  R"^\d+(\.\d*)?(e\d+)?$"? s -> Number{s}
                  s -> s

            match to-data{body, {= leaf}}:
               Array? ->
                  throw E.meta.invalid{"Meta-information must be key/value pairs."}
               obj ->
                  items{obj} each {key, value} ->
                     Into{.meta, {raw{key}, value}}

            ;; ex = extractor{"\\key = \\value", "\\key => \\value", "\\key: \\jsonvalue"}
            ;; statements{body} each stmt ->
            ;;    match ex{stmt}:
            ;;       {=> key, => value} ->
            ;;          Into{.meta, {raw{key}, value}}
            ;;       {=> key, => jsonvalue} ->
            ;;          Into{.meta, {raw{key}, toJSON{jsonvalue}}}
            ;;       else ->
            ;;          throw E.meta.syntax{'Invalid meta statement: "{stmt.raw{}}"'}

         else:
            Deferred with {path, docs} ->
               match docs.meta.get{r.replace{R"!$", ""}}:
                  undefined? ->
                     throw E.meta.missing{'No meta information: {r}'}
                  String? x when r.ends-with{"!"} ->
                     engine.gen-from-source{x}
                  ENode? x or String? x ->
                     x
                  node ->
                     engine.gen{node}

   }
