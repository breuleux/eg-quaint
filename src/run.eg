
require:
   child_process
   fs, path
   .index as quaint
   module
   globby
   mkdirp
   format-json


;; Small helpers

is-directory{path} =
   try:
      fs.stat-sync{path}.is-directory{}
   catch e:
      false

cli-error{msg, fn} =
   try:
      fn{}
   catch e:
      throw E.cli-error{msg, e}

module-here{} =
   m = new module{}
   m.filename = process.cwd{}
   c = process.cwd{}.split{"/"}
   m.paths = xs.reverse{} where xs = [1..c.length] each i ->
      c[...i].join{"/"} + "/node_modules"
   ;; Push global npm path
   m.paths.push with
      "/usr/local/lib/node_modules"
      "/usr/lib/node_modules"
      ;; child_process.spawn-sync{"npm", {.root, "-g"}}.stdout.to-string{}.trim{}
   m

normalize-qname{match t} =
   R".q$"? or false? ->
      t
   else ->
      t + ".q"


;; Large helpers


collate-sources{config, argv} =
   var source-dir = null
   var files = [Array! [config??.sources or {}]] ++ argv._
   sources = {}
   while files.length > 0:
      match files.shift{} as filename:
         match when is-directory{filename} ->
            when sources.length > 0 or files.length > 0 or source-dir ->
               throw E.cli-error{'Only one source directory can be specified.'}
            else ->
               source-dir = filename
               files ++= consume{globby.sync{'{filename}/**/*.q'}}
         else ->
            globby.sync{filename} each f ->
               sources.push with
                  {file = f,
                   contents = fs.read-file-sync{f, .utf8}}
   if argv.eval:
      sources.push with {file = "<cli>", contents = argv.e}
   {source-dir, sources}


collate-data{config, argv} =

   data-arguments = [config??.data-files or {}] ++ [argv.data or {}]

   json-filename{match f} =
      R"\."? -> f
      else -> f + ".json"

   json-parse{filename, contents} =
      cli-error{'Error parsing JSON in {filename}'} with ->
         JSON.parse{contents}

   data = config??.data or {=}

   [Array! data-arguments] each match entry ->
      undefined? -> pass
      R"^[\"']"? ->
         data &: json-parse{'argument {entry}', "{" + entry + "}"}
      R"^[{]"? ->
         data &: json-parse{'argument {entry}', entry}
      R"([a-zA-Z0-9_-]+)::(.*)"! {_, key, filename} ->
         f = json-filename{filename}
         contents = json-parse{'file {f}', fs.read-file-sync{f, .utf8}}
         data &: {key => contents}
      R"([a-zA-Z0-9_-]+):(.*)"! {_, key, value} ->
         try:
            data &: {key => JSON.parse{value}}
         catch e:
            data &: {key => value}
      filename ->
         f = json-filename{filename}
         data &: json-parse{'file {f}', fs.read-file-sync{f, .utf8}}

   data


resolve-plugins{config, argv} =
   plugins = argv.plugin

   m = module-here{}

   r{p} = module._load{p, m, true}

   inj = {}
   results = {}
   var spawned = false

   r2{name} =
      if spawned:
         r{name}
      else:
         try:
            r{name}
         catch e:
            ;; If all else fails (this is a bit slow, which is why we don't do it
            ;; if we don't have to)
            m.paths.push with
               child_process.spawn-sync{"npm", {.root, "-g"}}.stdout.to-string{}.trim{}
            spawned = true
            r{name}

   try-require{orig, match names, all = names} =
      {} ->
         rqs = [all each name -> '"{name}"'].join{", "}
         throw E.cli-error with
            'Could not find a plugin for "{orig}". I tried requiring the following modules: {rqs}.\nIf they are available on npm, you can install them locally or globally, then try again.'

      {name, *rest} ->
         try:
            r2{name}
         catch e:
            if e.message == 'Cannot find module \'{name}\'':
               try-require{orig, rest, all}
            else:
               throw E.cli-error with
                  'An error happened when loading module \'{name}\''
                  e

   resolve-string{match name, arg = null} =
      R"^([^()]+)\((.*)\)$"! {_, n, arg} ->
         resolve-string{n, JSON.parse{arg}}
      R"^([^{}]+)(\{.*\})$"! {_, n, arg} ->
         resolve-string{n, JSON.parse{arg}}

      R"^(\.+)([^/.]|$)"! {_, dots, _} ->
         resolve-string{dots + "/" + name.slice{dots.length}}

      R"\.q$"? ->
         inj.push with fs.read-file-sync{name, .utf8}
      R"^[./]"? ->
         pack = try-require{name, {name}}
         results.push with
            if{arg === null, pack, pack{arg}}
      else ->
         pack = try-require{name, {'quaint-{name}', name}}
         results.push with
            if{arg === null, pack, pack{arg}}

   resolve{config??.plugins or {}} where resolve{match entry} =
      Array? a ->
         a each x -> resolve{x}
      String? name ->
         results.push with try-require{name, {name}}
      else ->
         items{entry} each {name, arg} ->
            resolve-string{name, arg}

   resolve{plugins} where resolve{match name} =
      undefined? -> pass
      Array? ->
         name each n -> resolve{n}
      String? ->
         resolve-string{name}

   {inj = inj
    plugins = results}


run-template{q, source, t-specific, t-directory, verbose} =
   read-template{normalize-qname! match name} =
      "%%%" ->
         if verbose:
            console.error with 'quaint: using template "{t-specific}"'
         if R"\{"? t-specific:
            t-specific
         else:
            {file = t-specific
             contents = fs.read-file-sync{t-specific, .utf8}}
      else ->
         p = path.join{t-directory or ".", name}
         if verbose:
            console.error with 'quaint: using template "{p}"'
         {file = p
          contents = fs.read-file-sync{p, .utf8}}

   q.register-resolvers with {
      template = read-template
   }

   q.template = t-specific
   q.toHTML{source}


get-template{config, argv} =
   match [argv.template or config??.template]:
      t when is-directory{t} ->
         {null, t}
      true? t ->
         {normalize-qname{t}, null}
      else ->
         {null, "."}


;; Main method

provide{argv} =

   ;; DONE: config help eval format data plugin out
   ;;       save-meta stdout template verbose
   ;; TODO: save-config dump-data

   ;; helper function
   save-results{p >> p.replace{R".q$|$", ".html"}, contents} =
      out = argv.out or cfg??.output
      if argv.stdout or argv.eval and not out:
         print contents
      elif is-dir:
         p2 =
            if source-dir:
               path.join{out or "./", path.relative{source-dir, p}}
            else:
               path.join{out or "./", path.basename{p}}
         mkdirp.sync{path.dirname{p2}}
         fs.write-file-sync{p2, contents}
         if argv.verbose:
            console.error with 'quaint: wrote to "{p2}"'
      else:
         fs.write-file-sync{out, contents}
         if argv.verbose:
            console.error with 'quaint: wrote to "{out}"'

   ;; Configuration
   cfg-file = argv.config or "quaint.json"

   cfg-contents =
      try:
         fs.read-file-sync{cfg-file, .utf8}
      catch e:
         null

   cfg =
      cli-error{'Could not parse configuration file "{cfg-file}"'} with ->
         JSON.parse{cfg-contents}

   ;; Collect all the source files
   {source-dir, sources} = collate-sources{cfg, argv}

   ;; Error checking
   is-dir = [not R"\.[a-zA-Z0-9]+$"? argv.out] or is-directory{argv.out or "./"}
   if not argv.stdout and not is-dir and sources.length > 1:
      throw E.usage-error with
         "The -o option must point to a directory in order to process multiple files."

   ;; --data
   data = collate-data{cfg, argv}

   ;; --plugin
   {=> inj, => plugins} = resolve-plugins{cfg, argv}

   ;; --template
   {t-specific, t-directory} = get-template{cfg, argv}

   ;; Generate

   var sm = [argv.save-meta or cfg??.save-meta]
   if sm === true:
      sm = "meta.json"
   meta =
      if sm and fs.exists-sync{sm}:
         JSON.parse{fs.read-file-sync{sm, .utf8}}
      else:
         {=}

   sources each {=> file, => contents} ->
      if argv.verbose:
         console.error with 'quaint: processing "{file}"'
      q = quaint{*plugins}
      q.setenv{data}
      match [argv.format or cfg??.format or "html"]:
         .html ->
            result = run-template{
               q
               [inj ++ {contents}].join{""}
               t-specific
               t-directory
               argv.verbose
            }
            save-results{file, result}
            meta[file] = object with
               q.documents.meta.entries{} each {k, match v} ->
                  quaint.QAst? -> {k, v.raw{}}
                  else -> {k, v}
         else ->
            throw E.usage-error{"Format must be html"}

   if sm:
      mkdirp.sync{path.dirname{sm}}
      fs.write-file-sync{sm, format-json.plain{meta}}

