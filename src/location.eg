
provide:
   Source, Location
   <<:


binsearch{xs, x} =
   ;; Find an insertion point for x in the sorted array xs.
   ;; Returns an index i such that
   ;;   xs[i - 1] < x <= xs[i]
   ;; In particular,
   ;;   If x < xs[0]              ==> return 0
   ;;   If x > xs[xs.length - 1]  ==> return xs.length
   ;; Take note that
   ;;   If x == xs[i]             ==> return i + 1
   ;; The return value should not be interpreted as the index where x
   ;; is found, but some index where x can be safely spliced to
   ;; preserve the array's sortedness.
   var lo = 0
   var hi = xs.length - 1
   while [lo <= hi]:
      mid = lo + [[hi - lo] >> 1]
      v = xs[mid]
      match xs[mid]:
         [< x] ->
            set lo = mid + 1
         [> x] ->
            set hi = mid - 1
         [_] ->
            return [mid + 1]
   lo


class Source:

   constructor{text, url = false} =
      @text = text
      @url = url
      @counts = {}
      var curr = 0
      text.split{"\n"} each line ->
         @counts.push with curr
         curr += line.length + 1
      @counts.push with curr
      @nlines = @counts.length - 1

   linecol{pos} =
      line = binsearch{@counts, pos}
      col = pos - @counts[line - 1]
      {line, col}


class Location:

   constructor{source, start, end} =
      @source = source or Source{"", null}
      @start = start
      @end = end

   text{} =
      @source.text.slice{@start, @end}

   at_start{} =
      Location{@source, @start, @start}

   at_end{} =
      Location{@source, @end, @end}

   linerange{} =
      match @linecol{}:
         {{l1, _}, match} ->
            null? -> {l1, l1}
            {l2, _} -> {l1, l2}

   linecol{} =
      {start, end} where
         start = @source.linecol{@start}
         end = if [@start === @end]:
                  then: null
                  else: @source.linecol{@end - 1}

   ref{} =
      match @linecol{}:
         {{String! l1, String! c1}, match} ->
            null? ->
               l1 + ":" + c1
            {String! l2, String! c2} ->
               match:
                  when l1 === l2 and c1 === c2 ->
                     l1 + ":" + c1
                  when l1 === l2 ->
                     l1 + ":" + c1 + "-" + c2
                  otherwise ->
                     l1 + ":" + c1 + "-" + l2 + ":" + c2


x <<: y =
   if [not Location? x.location]:
      x.location = if{not y or Location? y, y, y.location}
   x
