

require:
   opg ->
      transferLocation as [<<:]
      Source
   .etools ->
      enode-to-data
   .tools ->
      may-fail
      parseSpec, makeExtractor, extractor
      raw, rawRelative, dedent, extract, collapse, statements
      shed, shedAll, shedIndent
      mergeable
      toJSON
   .doc ->
      SeqDocument, MapDocument
   .util ->
      insertSorted
   .ast ->
      QAst, Text, Oper, Seq
      Into, Deferred
   .format -> Format
   .include -> Include
   fs, path

provide:
   BasicEvaluator
   basicPlugin
   litPlugin
   file-resolver


requireWide{f}{engine, data} =
   if data._wide:
      f.call{this, engine, data}
   else:
      tools.next

headerRule{level}{engine, {=> x}} =
   gx = engine.gen{x}
   lbl = raw{x}.replace{R.g"\W", ""}.toLowerCase{}
   rval =
      ^[S'h{level}'] %
         id = lbl
         gx
         Into{.sections, {level, gx, lbl}}
   rval &: {block = true}

class BasicEvaluator:
   constructor{@store = Object.create{null}} =
      pass
   eval{expr, env = {=}, loc = null} =
      {key, *fields} = expr.split{"."}

      ;; s = Object.create{@store} &: env
      s = @store &: env
      if not Object.hasProperty.call{s, key}:
         try:
            JSON.parse{expr}
         catch _:
            throw E.not_in_environment{key}
      else:
         var v = s[key]
         fields each field -> v = v[field]
         v
   setenv{key, value} =
      @store[key] = value
   fork{} =
      BasicEvaluator with
         Object.create{@store}

file-resolver{options = {=}}{name} =
   with-extension = match name:
      R"\.[a-zA-Z0-9]+$"? -> name
      else -> '{name}.q'
   filename = match with-extension:
      R"^/"? -> with-extension
      else -> path.join{options.directory or "", with-extension}
   contents = [options.read-file or fs.read-file-sync]{filename, .utf8}
   {file = filename
    contents = contents}


conditional{engine, cond, value, falsey = ""} =
   engine.redefer{engine.gen{cond}} with {result} ->
      if result and not Error? result and not result.error:
         engine.gen{value}
      else:
         falsey and engine.gen{falsey}



litPlugin{@} =
   @clearRules{}
   @registerRules with {
      "{\\x}"{engine, {=> x}} =
         tools.code{engine, x}
   }


basicPlugin{@} =

   @registerDocuments with {
      meta = MapDocument{}
      sections = SeqDocument{}
   }

   @registerResolvers with {
      default = file-resolver{directory = ""}
      plugin{name} =
         try:
            __require{'quaint-{name}'}
         catch e1:
            try:
               __require{name}
            catch e2:
               throw e1
   }

   @evaluator = BasicEvaluator{}

   @register-macros with {

      "when"{engine, shed! cond, body} =
         conditional{engine, cond, body}

      "each"{engine, shed! list, *variables, body} =
         engine.redefer{engine.gen{list}} with {results} ->
            to-iterate = match enode-to-data{results} as x:
               {^Symbol.iterator => true?} ->
                  x
               else ->
                  items{x}
            vs = variables each v -> v.shed{}.raw{}
            enumerate{to-iterate} each {i, value} ->
               e = engine.fork{}
               e.setenv{"$i", i}
               match vs:
                  {} -> e.setenv{"$x", value}
                  {v} -> e.setenv{v, value}
                  else ->
                     zip{vs, value} each {v, x} ->
                        e.setenv{v, x}
               e.gen{body}

      store{engine, shed! raw! name, body} =
         if raw{body} == "dump!":
            engine.macros.dump{engine, name}
         else:
            Into{name, body, create{} = SeqDocument{}}

      dump{engine, shed! raw! name} =
         Deferred with {path, docs} ->
            match docs[name]:
               undefined? ->
                  ""
               doc ->
                  doc.entries{} each x -> engine.gen{x}

      css{engine, shed! body} =
         style[raw] % raw{body}

      html{engine, shed! body} =
         raw % raw{body}

      js{engine, shed! body} =
         script[raw] % raw{body}

      toc{engine, body} =
         Deferred with {path, docs} ->
            rval = [ul.toc %]
            stack = {}
            var cnode = rval
            var clvl = -1
            entries = match raw{body}:
               "" or .all -> docs.sections.entries{path}
               .below -> docs.sections.entriesAfter{path}
            entries each {match, title, lbl} ->
               do:
                  link = a %
                     href = S'#{lbl}'
                     title
               level == clvl or [level when clvl == -1] ->
                  clvl = level
                  cnode.children.push with li % link
               level > clvl ->
                  newnode = ul % li % link
                  cnode.children.push{newnode}
                  stack.push with {clvl, cnode}
                  {clvl, cnode} = {level, newnode}
               level < clvl ->
                  while level < clvl:
                     {clvl, cnode} = stack.pop{}
                  cnode.children.push{li % link}
            rval

      meta{engine, body} =
         r = raw{body}
         if r == "dump!":
            Deferred with {path, docs} ->
               table % docs.meta.entries{} each
                  {k, v} -> tr %
                     td % k
                     td % engine.gen{v}
         elif R"[=:]"? raw{body}:
            ex = extractor{"\\key = \\value", "\\key => \\value", "\\key: \\jsonvalue"}
            statements{body} each stmt ->
               match ex{stmt}:
                  {=> key, => value} ->
                     Into{.meta, {raw{key}, value}}
                  {=> key, => jsonvalue} ->
                     Into{.meta, {raw{key}, toJSON{jsonvalue}}}
                  else ->
                     throw E.meta.syntax{'Invalid meta statement: "{stmt.raw{}}"'}
         else:
            Deferred with {path, docs} ->
               match docs.meta.get{r}:
                  undefined? ->
                     throw E.meta.missing{'No meta information: {r}'}
                  ENode? x or String? x ->
                     x
                  node ->
                     engine.gen{node}

      template{match engine, tpl} =
         {top => false?} ->
            throw E.template.syntax{'Template must be specified at top level.'}
         {template => true? t} ->
            throw E.template.duplicate{'Template {t} was already specified for this file.'}
         else ->
            engine.template = tpl.raw{}

      scope{engine, body} =
         engine.fork{}.gen{body}

      plugins{engine, shed-all! raw! body} =
         r = engine.resolvers.plugin
         if not r:
            throw E.plugin{'Cannot resolve plugins.'}
         body.split{R"[ \n,]+"} each name ->
            p = r{name}
            p{engine}
         ""

      plugin{engine, raw! name, values} =
         r = engine.resolvers.plugin
         if not r:
            throw E.plugin{'Cannot resolve plugins.'}
         p = r{name}
         ex = extractor{"\\k = \\v", "\\k: \\v", "\\k => \\v"}
         options = object with
            values.statements{} each
               ex! {=> raw! k, => v} ->
                  {k, toJSON{v}}
               else ->
                  throw E.plugin{'Invalid option for plugin "{name}"'}
         p{engine, options}
         ""
   }

   fmt = Format{}
   @registerMacros with {
      format{engine, *[{descr, body} or {descr} and body is null]} =
         may-fail with ->
            fmt.format{engine, descr, body}
   }
   @macros.format.parsers = fmt.parsers
   @macros.format.formatters = fmt.formatters

   incl = Include{}
   @registerMacros with {
      include{engine, *[{ext, body} or {body} and ext is null]} =
         may-fail with ->
            incl.include{engine, ext??.raw{}, body}
   }
   @macros.include.extensions = incl.extensions

   @registerMethods with {
      method lit{} =
         p = @fork-plug{litPlugin}
         p.evaluator = @evaluator
         p
      method litgen{x} =
         @lit{}.gen{x}
   }

   percent-syntax{engine, descr, contents} =
      leng = engine.lit{}

      ex = extractor{"\\key = \\value"}
      props = {=}
      stmts = statements{contents} each
         ex! {key => raw! key, => value} ->
            props[key] = leng.gen{value}
            continue
         stmt ->
            stmt
      children =
         if props != {=}:
            [% stmts each stmt -> engine.gen{stmt}].join{"\n"}.children
         else:
            s = shedIndent{contents}
            if s == Text{""}:
               {}
            else:
               {engine.gen{s}}

      parts = raw{descr}.split{R"[ +]|(?=\.|#)"}
      var id = null
      tags = {}
      parts each
         "" ->
            pass
         R"^#(.*)"! {_, _id} ->
            id = _id
         tag ->
            tags.push with tag
      if id: props.id = id
      ENode{tags, props, children}


   @registerRules with {

      "\\maybe\\x ;; \\ignore"{engine, {=> x}} =
         engine.gen{x}

      "[\\maybe\\x]"{engine, {_node => Seq? {_, o, x, c, _}}} =
         beg = raw{o}.replace{"[", ""}
         middle = engine.gen{x}
         end = raw{c}.replace{"]", ""}
         res =
            if beg or end:
               % [beg, middle, end]
            elif middle.block:
               % middle
            else:
               middle
         if middle.block:
            res &: {block = middle.block}
         res

      "{\\x}"{engine, {=> x}} =
         tools.code{engine, x}

      "\\fna :: \\maybe\\body"{engine, {=> fna, => body}} =
         may-fail with ->
            {fn, *args} =
               match fna:
                  extract! Seq? {"J", *args} ->
                     args
                  else ->
                     {fna}
            rf = raw{fn}
            if engine.macros[rf] as f:
               f{engine, *args, body} or ""
            else:
               Deferred with {path, documents} ->
                  may-fail with ->
                     f2 = engine.eval{rf, {=}, fn.location}
                     f2.apply{null, {engine, *args, body}} or ""

      "_ \\x"{engine, {=> x}} =
         em % engine.gen{x}

      "__ \\x"{engine, {=> x}} =
         strong % engine.gen{x}

      "` \\x"{engine, {x => shed! x}} =
         code % raw{x}.replace{R.g"\\+[{}()\[\]]", x -> x.slice{1}}

      "& \\x"{engine, {x => shed! x}} =
         pre % dedent{rawRelative{x}.replace{R"^ *\n", ""}}

      "\\maybe\\label @@ \\url"{engine, {=> label, url => shed! url}} =
         url2 = engine.litgen{url}
         a %
            href = url2
            if{label == Text{""}, url2, engine.gen{label}}

      "\\maybe\\label @@ image : \\url"{engine, {=> label, url => shed! url}} =
         lbl = engine.litgen{label}
         img %
            src = engine.litgen{url}
            alt = lbl
            title = lbl

      "\\url @@ image"{engine, {url => shed! url}} =
         img % src = engine.litgen{url}

      "\\descr % \\contents"{engine, spec} =
         spec as {=> shed! descr, => contents}
         percent-syntax{engine, descr, contents}

      requireWide! "\\descr % \\maybe\\contents"{engine, spec} =
         spec as {=> shed! descr, => contents}
         percent-syntax{engine, descr, contents}

      requireWide! "= \\x" = headerRule{1}
      requireWide! "== \\x" = headerRule{2}
      requireWide! "=== \\x" = headerRule{3}
      requireWide! "==== \\x" = headerRule{4}
      requireWide! "===== \\x" = headerRule{5}
      requireWide! "====== \\x" = headerRule{6}

      requireWide! "# \\x"{engine, {=> x}} =
         mergeable{.ol, li % engine.gen{x}}

      requireWide! "* \\x"{engine, {=> x}} =
         mergeable{.ul, li % engine.gen{x}}

      requireWide! "+ \\x"{engine, {=> x}} =
         args = collapse{"+", x}
         mergeable{.table} with
            tr %
               args each arg ->
                  th % engine.gen{arg}

      requireWide! "> \\x"{engine, {=> x}} =
         mergeable{.blockquote, {" ", engine.gen{x}}}

      requireWide! "| \\x"{engine, {=> x}} =
         args = collapse{"|", x}
         mergeable{.table} with
            tr %
               args each arg ->
                  td % engine.gen{arg}

      "\\rule => \\body"{engine, {rule => shed! raw! rule
                                  body => shed! shedIndent! body}} =
         match rule:
            R"^/(.*)/$"! {_, regexp} ->
               engine.register-postprocessor{regexp} with {*matches} ->
                  values = object with enumerate{matches} each
                     {i, m} -> {S'm{i}', m}
                  e = engine.fork{}
                  e.regexps = {}
                  e.setenv{values}.translate{body, .enode}
               null
            parseSpec! [spec and {top, match tree, specificity}] ->
               #put ->
                  throw E.too_general{rule}
               #eq{Text? {name}} ->
                  engine.setenv{name, body}
               else ->
                  engine.registerRules{spec} with {engine, values} ->
                     engine.fork{}.setenv{values}.gen{body}

         ""

      "\\cond ?? \\value"{engine, {=> shed! cond, => value}} =
         conditional{engine, cond, value}

      "\\cond ?? \\value !! \\falsey"{engine, {=> shed! cond, => value, => falsey}} =
         conditional{engine, cond, value, falsey}

      "\\cond !! \\falsey"{engine, {=> shed! cond, => falsey}} =
         conditional{engine, cond, cond, falsey}

      ;; newline rule is a bit more complicated
      newlineRule = {spec, fn} where

         filter{match node} =
            extract! Seq? {"NL", *args} ->
               {args = args}
            else ->
               false

         spec = {"NL", #fn{filter}, 1}

         fn{engine, {_node => node and Seq? {*elems}, => args}} =
            results = {}
            wide = node.width == .wide
            var last = null
            _gen = engine.gen.bind{engine}
            var i = -3

            add{addblank = true} =
               results.push with
                  match last:
                     [div %]? or {block => true?} ->
                        last
                     != "" when wide ->
                        p % last
                     else ->
                        last
               if addblank:
                  results.push with
                     raw{elems[i]}

            var isFirst = true
            args each [_gen! match] ->
               do:
                  i += 2
               x when isFirst ->
                  isFirst = false
                  last = x
               x ->
                  add{}
                  last = x
            i += 2
            if last:
               add{false}

            match results:
               {result} ->
                  result
               else ->
                  [% results] &: {block = Boolean! wide}
   }
