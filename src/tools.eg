
require:
   opg ->
      Source, Location
   "./lang" -> parse

provide:
   raw, code, rawOrCode
   parseSpec, makeExtractor, extractor
   extract, collapse, statements
   shed, shedAll, shedIndent
   mergeable



raw{match x, operate = {x} -> x} =
   {=> location} -> location.text{}
   String? -> operate{x}
   [genfrom %]? ->
      genfrom %
         generate{docs} =
            raw{x.props.generate{docs}}
   else -> throw E.noraw{S'Cannot get a raw string from {x}.'}

code{engine, x} =
   genfrom %
      generate{documents} =
         try:
            engine.setenv{.doc, documents}
            engine.setenv{.documents, documents}
            engine.eval{x.location} or ""
         catch e:
            span.error % String{e}

rawOrCode{engine, match x, operate = {x} -> x} =
   #seq{_, #oper{"{"}, x, #oper{"}"}, _} ->
      raw{code{engine, x}, operate}
   else ->
      raw{x, operate}



parseSpec{match} =
   String? spec ->
      let ast = parse{Source{spec}}
      var top = null
      rval = helper{ast, {shed = true}} where helper{match, opts} =
         extract! #seq{"J", *tags, pattern} ->
            helper{pattern} with
               opts &
                  object with tags each #text{tag} -> {tag, true}
         ast when opts.wide ->
            #iswide{helper{ast, opts & {wide = false}}}
         ast when opts.short ->
            #isshort{helper{ast, opts & {short = false}}}
         #text{""} ->
            #eq{#text{""}}
         #text{v} ->
            #put{v, opts.maybe === true}
         #oper{op} ->
            #eq{#oper{op}}
         #seq{_, #oper{"["}, contents, #oper{"]"}, _} when opts.shed ->
            helper{contents, opts & {shed = false}}
         #seq{*args} and {=> operator} ->
            if [not top]:
               top = operator
            #seq{*[args each arg -> helper{arg, opts}]}
      {top, rval}
   {top, rval} ->
      {top, rval}

makeExtractor{parseSpec! {top, spec}} =
   {top} with {node} ->
      helper{spec, node} where
         helper{match, node} =
            #iswide{subspec} ->
               [node.width == .wide] and
                  helper{subspec, node}
            #isshort{subspec} ->
               [node.width == .short] and
                  helper{subspec, node}
            #put{v, maybe} ->
               match node:
                  #text{""} when not maybe ->
                     false
                  else ->
                     {v => node}
            #eq{== node} ->
               {=}
            #eq ->
               false
            #seq{*subspecs} ->
               match node:
                  #seq{*args} when subspecs.length == args.length ->
                     rval = {=}
                     zip{subspecs, args} each {subspec, arg} ->
                        match helper{subspec, arg}:
                           false? ->
                              return false
                           vars ->
                              rval &: vars
                     rval
                  other ->
                     false
            #fn{f} ->
               f{node}

rules = {=}

extractor{*rules} =
   extractors = rules each
      rule when rules[rule] -> rules[rule]
      rule ->
         {_, ex} = makeExtractor{rule}
         rules[rule] = ex
         ex
   {node} ->
      extractors each ex ->
         if [res = ex{node}]:
            return res
      return false


extract{match} =
   #seq{*args} ->
      #seq{args[1][1], *newargs} where newargs =
         enumerate{args} each
            {i, arg} when i mod 2 == 0 ->
               arg
   other ->
      other

collapse{operator, match} =
   ;; TODO: take width into account
   extract! #seq{=== operator, l, r} ->
      {l} ++ collapse{operator, r}
   node ->
      {node}

statements{shedIndent! match node} =
   #seq{_, #oper{"NL"}, *} ->
      [xs.reduce{++}] where xs =
         enumerate{node.slice{1}} each
            {i, x} when i mod 2 == 0 ->
               statements{x}
   #text{""} ->
      {}
   else ->
      {node}



shed{match, n = 1} =
   #seq{_, ob and #oper{"["}, mid, cb and #oper{"]"}, _} ->
      if n > 1:
         shed{mid, n - 1}
      else:
         lw = raw{ob}.split{"["}.pop{}
         rw = raw{cb}.split{"]"}.shift{}
         loc = mid.location
         mid & {
            location = Location{loc.source, loc.start - lw.length, loc.end + rw.length}
         }
   node ->
      node

shedAll{node} =
   shed{node, 1/0}

shedIndent{match node} =
   #seq{_, #oper{"I("}, mid, #oper{")I"}, _} ->
      match mid:
         #seq{#text{""}, #oper{"NL"}, x} ->
            x
         #seq{#text{""}, #oper{"NL"}, *rest} ->
            #seq{*rest} &: mid
         else ->
            mid
   node ->
      node



mergeable{tag, child, block = true} =
   merge{match node} =
      [^tag %]! {tags, props, children} ->
         this.children ++= children
         this
      other ->
         false
   node = ^tag % child
   node.block = block
   node.merge = merge
   node


