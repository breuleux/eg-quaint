
require:
   opg ->
      Source, Location
   "./lang" ->
      parse, Text, Oper, Seq

provide:
   next
   raw, rawRelative, dedent, code, rawOrCode
   parseSpec, makeExtractor, extractor
   ;; parseSpec2, makeExtractor2, extractor2
   extract, collapse, statements
   shed, shedAll, shedIndent
   mergeable


next = Symbol{.next}


raw{match x, operate = {x} -> x} =
   {=> location} -> location.text{}
   String? -> operate{x}
   [genfrom %]? ->
      genfrom %
         generate{path, docs} =
            raw{x.props.generate{path, docs}}
   else -> throw E.noraw{S'Cannot get a raw string from {x}.'}

rawRelative{match x} =
   {=> location} ->
      {{_, c}, _} = location.linecol{}
      padding = [1..c each i -> " "].join{""}
      padding + location.text{}
   String? -> x
   else -> throw E.noraw{S'Cannot get a raw string from {x}.'}

dedent{x} =
   lines = x.split{"\n"}
   indents = lines each R"^( *)"! {_, pfx} -> pfx.length
   min = Math.min{*indents}
   newlines.join{"\n"} where
      newlines = lines each line -> line.slice{min}


code{engine, x} =
   genfrom %
      generate{path, documents} =
         try:
            res = engine.eval{raw{x}, env, x.location} or "" where
               env = {doc and documents = documents}
            match res:
               {qast => true?} ->
                  engine.gen{res}
               else ->
                  res
         catch e:
            span.error % String{e}

rawOrCode{engine, match x, operate = {x} -> x} =
   #seq{_, #oper{"{"}, x, #oper{"}"}, _} ->
      raw{code{engine, x}, operate}
   else ->
      raw{x, operate}


parseSpec{match} =
   String? spec ->
      let ast = parse{Source{spec}}
      var top = null
      var specificity = 0
      rval = helper{ast, {shed = true}} where helper{match expr, opts} =
         #text{R"^\\(?:([^\\]*)\\)?(.*)$"! {_, match flag, name}} ->
            "maybe" -> #put{name, true}
            else -> #put{name, false}
         #text ->
            specificity += 100
            #eq{expr}
         #oper{op} ->
            #eq{#oper{op}}
         #seq{*args} and {=> operator} ->
            specificity += 1
            if [not top]:
               top = operator
            Seq{*[args each arg -> helper{arg, opts}]}
      {top, rval, specificity}
   {top, rval, specificity} ->
      {top, rval, specificity}

makeExtractor{parseSpec! {top, tree, specificity}} =
   helper{match x, node} =
      #put{v, maybe = true} ->
         match node:
            #text{""} when not maybe ->
               false
            else ->
               {v => node}
      #eq{match} ->
         == node -> {=}
         else -> false
      #seq{*subtrees} ->
         match node:
            #seq{*args} when subtrees.length == args.length ->
               rval = {=}
               zip{subtrees, args} each {subtree, arg} ->
                  match helper{subtree, arg}:
                     false? ->
                        return false
                     vars ->
                        rval &: vars
               rval
            other ->
               false
      #fn{f} ->
         f{node}
   {top, specificity, fn} where
      fn{node} = helper{tree, node}

ruleBank = {=}

extractor{*rules} =
   extractors = rules each
      rule when ruleBank[rule] -> ruleBank[rule]
      rule ->
         {_, _, ex} = makeExtractor{rule}
         ruleBank[rule] = ex
         ex
   f{node} =
      extractors each ex ->
         if [res = ex{node}]:
            return res
      return false
   f[":::project"]{x} =
      match f{x}:
         === false ->
            {false, null}
         values ->
            {true, values}
   f


extract{match} =
   #seq{*args} ->
      Seq{args[1][1], *newargs} where newargs =
         enumerate{args} each
            {i, arg} when i mod 2 == 0 ->
               arg
   other ->
      other

collapse{operator, match} =
   ;; TODO: take width into account
   extract! #seq{=== operator, l, r} ->
      {l} ++ collapse{operator, r}
   node ->
      {node}

statements{shedIndent! match node} =
   #seq{_, #oper{"NL"}, *} ->
      [xs.reduce{++}] where xs =
         enumerate{node.slice{1}} each
            {i, x} when i mod 2 == 0 ->
               statements{x}
   #text{""} ->
      {}
   else ->
      {node}



shed{match, n = 1} =
   #seq{_, ob and #oper{"["}, mid, cb and #oper{"]"}, _} ->
      if n > 1:
         shed{mid, n - 1}
      else:
         lw = raw{ob}.split{"["}.pop{}
         rw = raw{cb}.split{"]"}.shift{}
         loc = mid.location
         mid & {
            location = Location{loc.source, loc.start - lw.length, loc.end + rw.length}
         }
   node ->
      node

shedAll{node} =
   shed{node, 1/0}

shedIndent{match node} =
   #seq{_, #oper{"I("}, mid, #oper{")I"}, _} ->
      match mid:
         #seq{#text{""}, #oper{"NL"}, x} ->
            x
         #seq{#text{""}, #oper{"NL"}, *rest} ->
            Seq{*rest} &: mid
         else ->
            mid
   node ->
      node



mergeable{tag, child, block = true} =
   merge{match node} =
      [^tag %]! {tags, props, children} ->
         this.children ++= children
         this
      other ->
         false
   node = ^tag % child
   node.block = block
   node.merge = merge
   node


