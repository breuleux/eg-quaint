
require:
   opg ->
      Source, Location
   "./lang" ->
      parse, QAst, Text, Oper, Seq

provide:
   next
   may-fail
   raw, rawRelative, dedent, code
   parseSpec, makeExtractor, extractor
   extract, collapse, statements
   shed, shedAll, shedIndent
   mergeable
   normalize


next = Symbol{.next}


may-fail{f} =
   try:
      f{}
   catch e:
      span.error % String{e}


raw{match x, operate = {x} -> x} =
   QAst? -> x.raw{}
   String? -> operate{x}
   [genfrom %]? ->
      genfrom %
         generate{path, docs} =
            raw{x.props.generate{path, docs}}
   else -> throw E.noraw{S'Cannot get a raw string from {x}.'}

rawRelative{match x} =
   {=> location} ->
      {{_, c}, _} = location.linecol{}
      padding = [1..c each i -> " "].join{""}
      padding + location.text{}
   String? -> x
   else -> throw E.noraw{S'Cannot get a raw string from {x}.'}

dedent{x} =
   lines = x.split{"\n"}
   indents = lines each
      R"^( *)(?! |$)"! {_, pfx} -> pfx.length
      else -> continue
   min = Math.min{*indents}
   newlines.join{"\n"} where
      newlines = lines each line -> line.slice{min}


code{engine, x} =
   genfrom %
      generate{path, documents} =
         may-fail with ->
            res = engine.eval{raw{x}, env, x.location} or "" where
               env = {doc and documents = documents}
            match res:
               QAst? ->
                  engine.gen{res}
               else ->
                  res


parseSpec{match} =
   String? spec ->
      let ast = parse{Source{spec}}
      var top = null
      var specificity = 0
      rval = helper{ast, {shed = true}} where helper{match expr, opts} =
         Text? {R"^\\(?:([^\\]*)\\)?(.*)$"! {_, match flag, name}} ->
            "maybe" -> #put{name, true}
            else -> #put{name, false}
         Text? ->
            specificity += 100
            #eq{expr}
         Oper? ->
            #eq{expr}
         Seq? {*args} and {=> operator} ->
            specificity += 1
            if [not top]:
               top = operator
            #seq{*[args each arg -> helper{arg, opts}]}
      {top, rval, specificity}
   {top, rval, specificity} ->
      {top, rval, specificity}

makeExtractor{parseSpec! {top, tree, specificity}} =
   helper{match x, node} =
      #put{v, _maybe = true} ->
         match node:
            Text? {""} when not _maybe ->
               false
            else ->
               {v => node}
      #eq{match} ->
         == node -> {=}
         else -> false
      #seq{*subtrees} ->
         match node:
            Seq? {*args} when subtrees.length == args.length ->
               rval = {=}
               zip{subtrees, args} each {subtree, arg} ->
                  match helper{subtree, arg}:
                     false? ->
                        return false
                     vars ->
                        rval &: vars
               rval
            other ->
               false
      #fn{f} ->
         f{node}
   {top, specificity, fn} where
      fn{node} = helper{tree, node}

ruleBank = {=}

extractor{*rules} =
   extractors = rules each
      rule when ruleBank[rule] -> ruleBank[rule]
      rule ->
         {_, _, ex} = makeExtractor{rule}
         ruleBank[rule] = ex
         ex
   f{node} =
      extractors each ex ->
         if [res = ex{node}]:
            return res
      return false
   f[":::project"]{x} =
      match f{x}:
         === false ->
            {false, null}
         values ->
            {true, values}
   f


extract{match} =
   Seq? {*args} ->
      Seq{args[1][0], *newargs} where newargs =
         enumerate{args} each
            {i, arg} when i mod 2 == 0 ->
               arg
   other ->
      other

collapse{operator, match} =
   ;; TODO: take width into account
   extract! Seq? {=== operator, l, r} ->
      {l} ++ collapse{operator, r}
   node ->
      {node}

statements{shedIndent! match node} =
   Seq? {_, Oper? {"NL"}, *} ->
      [xs.reduce{++}] where xs =
         enumerate{node} each
            {i, x} when i mod 2 == 0 ->
               statements{x}
   Text? {""} ->
      {}
   else ->
      {node}



shed{match, n = 1} =
   Seq? {_, ob and Oper? {"["}, mid, cb and Oper? {"]"}, _} ->
      if n > 1:
         shed{mid, n - 1}
      else:
         lw = raw{ob}.split{"["}.pop{}
         rw = raw{cb}.split{"]"}.shift{}
         loc = mid.location
         mid & {
            location = Location{loc.source, loc.start - lw.length, loc.end + rw.length}
         }
   node ->
      node

shedAll{node} =
   shed{node, 1/0}

shedIndent{match node} =
   Seq? {_, Oper? {"I("}, mid, Oper? {")I"}, _} ->
      match mid:
         Seq? {Text? {""}, Oper? {"NL"}, x} ->
            x
         Seq? {Text? {""}, Oper? {"NL"}, *rest} ->
            Seq{*rest} &: mid
         else ->
            mid
   node ->
      node



mergeable{tag, child, block = true} =
   merge{match node} =
      [^tag %]! {tags, props, children} ->
         this.children ++= children
         this
      other ->
         false
   node = ^tag % child
   node.block = block
   node.merge = merge
   node


blockElements = [object with elems.split{R"[\n ]+"} each x -> {x, true}] where
   elems = """
      address article aside audio
      blockquote
      canvas
      dd div dl
      fieldset figcaption figure footer form
      h1 h2 h3 h4 h5 h6 header hgroup hr
      main
      nav noscript
      ol output
      p pre
      section
      table tfoot
      ul
      video
      html head body link script
      raw top
   """

normalize{match node} =
   ENode? {tags => {.p}, props => == {=}, children => {R"^[\n ]*$"?} or {}} ->
      ""
   ENode? {tags => match tags, props => props == {=}, => children} ->
      {.p} ->
         ch = normalize{children}
         ch each
            ENode? {=> tags} when tags.some{t -> blockElements[t]} ->
               return ch
            else ->
               pass
         ENode{tags, props, ch}
      else ->
         ENode{tags, props, normalize{children}}
   Array? children ->
      var res = {}
      children each normalize! match ->
         Array? a -> res ++= a
         other -> res.push{other}
      res
   else ->
      node
