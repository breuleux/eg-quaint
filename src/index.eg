
require:
   opg ->
      tokenize ->
         SimpleTokenizer, indentTracker, inferLocation
      parse ->
         Parser, TokenGroups, PriorityOrder


tok = new SimpleTokenizer with {

   regexps = {
      {.nl, " *(?:\n *)+"}
      {.ws, " +"}
      {.op, "[!@#$%^&*_\\-+=<>/?;:.`|]+|[(){}\\[\\],.]"}
      {.word, "[^\n!@#$%^&*_\\-+=<>/?;:.`|\\[\\](){},. ]+"}
      {.unknown, "."} ;; should never happen
   }

   post = {
      indentTracker{calcSize}
      addDefaults
      tuckWhitespace
      classifyOperators
   } where

      calcSize{match token} =
         {type => .nl} ->
            {*, x} = token.token.split{"\n"}
            x.length
         else ->
            -1

      addDefaults{token} =
         token &: {wsb = 0, wsa = 0}

      tuckWhitespace{match tok, i, toks} =
         do:
            {prev, next} = {toks[i-1], toks[i+1]}
         {type => .ws, => token} ->
            prev.wsa and next.wsb = token.length
            next.tucked = tok
            {}
         {type => .indent} ->
            prev.wsa = 1
            {tok}
         else ->
            {tok}

      classifyOperators{match tok} =
         do:
            tuck = tok.tucked
            delete tok.tucked
            sfx = this.sfx
            pad{tok} =
               if sfx:
                  padder = tuck or {
                     type = .sh_ws, token = ""
                     start = tok.start, end = tok.end
                  }
                  {padder, tok}
               else:
                  {tok}

         {type => [.boundary or .ws or .indent]} ->
            this.sfx = false
            {tok}

         {type => .nl, => token} ->
            this.sfx = false
            if token.split{"\n"}.length <= 2:
               tok.type = .sh_nl
            {tok}

         {type => .dedent} ->
            this.sfx = true
            {tok}

         {type => .word} ->
            this.sfx = true
            pad{tok}

         {type => .op, => token, => wsb, => wsa} ->
            var never_sfx = false
            match tok.token:
               "(" or "[" or "{" ->
                  tok.type = .open
                  this.sfx = false
                  return pad{tok}
               ")" or "]" or "}" ->
                  tok.type = .close
                  this.sfx = true
                  return {tok}
               "," or ":" ->
                  never_sfx = true
               else ->
                  pass

            {tok.type, this.sfx, get} =
               match {sfx, wsb, wsa}:
                  {true?,  0  , 0}     -> {.sh_ifx, false, {tok}}
                  {true?,  > 0, > 0}   -> {.wi_ifx, false, {tok}}
                  {true?,  _  , 0}     -> {.sh_pfx, false, pad{tok}}
                  {true?,  0  , _}     -> {if{never_sfx, .wi_ifx, .sh_sfx}, false, {tok}}
                  {false?, 0  , 0}     -> {.sh_pfx, true,  {tok}}
                  {false?, > 0, > 0}   -> {.wi_pfx, true,  {tok}}
                  {false?, _  , 0}     -> {.sh_pfx, true,  {tok}}
                  {false?, 0  , _}     -> {.wi_pfx, true,  {tok}}

         else ->
            throw E.unknown_token_type{String{tok}}

}


prio = new PriorityOrder{tokgrp, priorities} where

   tokgrp = new TokenGroups with {
      sh_pfx = {.sh_pfx}
      sh_ifx = {.sh_ifx}
      sh_sfx = {.sh_sfx}
      wi_pfx = {.wi_pfx}
      wi_ifx = {.wi_ifx}
      wi_sfx = {.wi_sfx}
      sh_ws = {.sh_ws}
      ws = {.ws}
      sh_nl = {.sh_nl}
      nl = {.nl}
      indent = {.indent}
      dedent = {.dedent}
      openp = {"open ("}
      closep = {"close )"}
      opens = {"open ["}
      closes = {"close ]"}
      openb = {"open {"}
      closeb = {"close }"}
      period = {"sh_sfx ."}
      word = {.word}
      boundary = {.boundary}
   }

   MAX = Infinity

   priorities = {
      indent = {left = 280, right = 1}
      dedent = {left = 1  , right = MAX}
      opens  = {left = MAX, right = 2}
      closes = {left = 2  , right = MAX}
      openb  = {left = MAX, right = 3}
      closeb = {left = 3  , right = MAX}
      openp  = {left = MAX, right = 4}
      closep = {left = 4  , right = MAX}

      nl     = {left = 100, right = 100}
      sh_nl  = {left = 150, right = 150}

      wi_pfx = {left = MAX, right = 200}
      wi_ifx = {left = 201, right = 200}
      wi_sfx = {left = 201, right = MAX}
      ws     = {left = 250, right = 250}

      period = {left = 299, right = MAX}
      sh_pfx = {left = MAX, right = 300}
      sh_ifx = {left = 301, right = 300}
      sh_sfx = {left = 301, right = MAX}
      sh_ws  = {left = 350, right = 350}

      word   = {left = 1000, right = 1000}
      boundary = {left = -1, right = -1}
   }


parser = new Parser{tok, prio.getOrder{}}

