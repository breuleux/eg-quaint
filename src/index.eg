
require:
   opg ->
      Source, Location
      transferLocation as [<<:]
   "./lang" ->
      parse
   "./tools" as tools ->
      raw, extract, collapse, statements
      shed, shedAll, shedIndent
      mergeable

provide:
   parse
   Location, Source
   Quaint, QuaintFor
   create
   toENode, toHTML
   processDocuments
   tools


parse_spec{match} =
   String? spec ->
      let ast = parse{Source{spec}}
      var top = null
      rval = helper{ast, {shed = true}} where helper{match, opts} =
         extract! #seq{"J", *tags, pattern} ->
            helper{pattern} with
               opts &
                  object with tags each #text{tag} -> {tag, true}
         ast when opts.wide ->
            #iswide{helper{ast, opts & {wide = false}}}
         ast when opts.short ->
            #isshort{helper{ast, opts & {short = false}}}
         #text{""} ->
            #eq{#text{""}}
         #text{v} ->
            #put{v, opts.maybe === true}
         #oper{op} ->
            #eq{#oper{op}}
         #seq{_, #oper{"["}, contents, #oper{"]"}, _} when opts.shed ->
            helper{contents, opts & {shed = false}}
         #seq{*args} and {=> operator} ->
            if [not top]:
               top = operator
            #seq{*[args each arg -> helper{arg, opts}]}
      {top, rval}
   {top, rval} ->
      {top, rval}


make_extractor{parse_spec! {top, spec}} =
   {top} with {node} ->
      helper{spec, node} where
         helper{match, node} =
            #iswide{subspec} ->
               [node.width == .wide] and
                  helper{subspec, node}
            #isshort{subspec} ->
               [node.width == .short] and
                  helper{subspec, node}
            #put{v, maybe} ->
               match node:
                  #text{""} when not maybe ->
                     false
                  else ->
                     {v => node}
            #eq{== node} ->
               {=}
            #eq ->
               false
            #seq{*subspecs} ->
               match node:
                  #seq{*args} when subspecs.length == args.length ->
                     rval = {=}
                     zip{subspecs, args} each {subspec, arg} ->
                        match helper{subspec, arg}:
                           false? ->
                              return false
                           vars ->
                              rval &: vars
                     rval
                  other ->
                     false
            #fn{f} ->
               f{node}



class Dispatcher:

   constructor{} =
      @dispatch = {}

   handler{node} =
      key = node.operator or ""
      if not key:
         console.error with
            "Node lacks an operator key. That may be indicative of a bug."
      match @dispatch[key]:
         undefined? ->
            false
         candidates ->
            candidates each c ->
               match node:
                  c! parts ->
                     return {parts, c}
                  else ->
                     pass
            false

   register{handler} =
      key = handler.operator
      l = [@dispatch[key] or= {}]
      l.unshift with handler

   clone{} =
      d = Dispatcher{}
      d.dispatch = object with items{@dispatch} each {key, l} ->
         {key, l.slice{0}}
      d


class Engine:

   constructor{@dispatch, @evaluator} =
      pass


   run{src, documents = undefined} =

      generated =
         match src:
            String? text ->
               @run{Source{text, "<quaint>"}, documents}
            Source? src ->
               parsed = parse{src}
               @gen{parsed}
            node ->
               @gen{node}

      match documents:
         undefined? ->
            processDocuments{generated, {=}}
         null? ->
            generated
         else ->
            processDocuments{generated, documents}


   .gen{match node} =
      
      #text{t} or #oper{t} ->
         l = node.location
         r = R.g"~|\\[\\~!@#$%^&*_\-+=<>/?;:.`|(){}\[\],.]"
         node.location.text{}.replace{r} with {match} ->
            "~" -> ""
            s -> s[1]
      #seq{*parts} ->
         result = match @dispatch.handler{node}:
            false? ->
               %
                  parts each part -> @gen{part}
            {values, handler} ->
               handler.gen{@, {node = node} & values}
         match result:
            ENode? {tags => {}, props => == {=}, => children} or Array? children
            \ when children.every{x -> String? x} ->
               r = children.join{""}
               if{result.block, % r, r}
            else ->
               result

   register{spec, dispatcher} =
      @dispatch.register{Spec{spec, dispatcher}}
      @

   registerAll{entries} =
      items{entries} each {spec, dispatcher} ->
         @register{spec, dispatcher}
      @

   eval{src} =
      @evaluator.eval{src}

   setenv{name, value} =
      @evaluator.setenv{name, value}


class Spec:
   constructor{make_extractor! {@operator, @extractor}, @gen} =
      pass
   ":::project"{@extractor! match} =
      false? ->
         {false, null}
      values ->
         {true, values}


defaultComponents{ENode} = {

   "[[maybe x]]"{engine, {node => #seq{_, o, x, c, _}}} =
      beg = raw{o}.replace{"[", ""}
      middle = engine.gen{x}
      end = raw{c}.replace{"]", ""}
      ;; print {beg, middle, end, raw{middle}}
      res =
         if beg or end:
            % [beg, middle, end]
         else:
            middle
      res &: {block = middle.block}

   "{x}"{engine, {=> x}} =
      tools.code{engine, x}

   "{fn} : body"{engine, {=> fn, => body}} =
      try:
         f = engine.eval{fn.location}
         f{engine, body} or ""
      catch e:
         span.error % String{e}

   "_ x"{engine, {=> x}} =
      em % engine.gen{x}

   "__ x"{engine, {=> x}} =
      strong % engine.gen{x}

   "` x"{engine, {x => shed! x}} =
      code % raw{x}

   "label :: url"{engine, {=> label, url => shed! url}} =
      a %
         href = tools.rawOrCode{engine, url, {s} -> s.trim{}}
         engine.gen{label}

   "descr .. maybe contents"{engine, {=> descr, => contents}} =
      parts = raw{descr}.split{R"[ +]|(?=\.|#)"}
      var id = null
      tags = {}
      parts each
         "" ->
            pass
         R"^#(.*)"! {_, _id} ->
            id = _id
         tag ->
            tags.push with tag
      props = {=}
      if id: props.id = id
      ENode{tags, props, {engine.gen{shedIndent{contents}}}}

   "wide [= x]"{engine, {=> x}} =
      [h1 % engine.gen{x}] &: {block = true}
   "wide [== x]"{engine, {=> x}} =
      [h2 % engine.gen{x}] &: {block = true}
   "wide [=== x]"{engine, {=> x}} =
      [h3 % engine.gen{x}] &: {block = true}
   "wide [==== x]"{engine, {=> x}} =
      [h4 % engine.gen{x}] &: {block = true}
   "wide [===== x]"{engine, {=> x}} =
      [h5 % engine.gen{x}] &: {block = true}
   "wide [====== x]"{engine, {=> x}} =
      [h6 % engine.gen{x}] &: {block = true}

   "wide [# x]"{engine, {=> x}} =
      mergeable{.ol, li % engine.gen{x}}

   "wide [* x]"{engine, {=> x}} =
      mergeable{.ul, li % engine.gen{x}}

   "wide [+ x]"{engine, {=> x}} =
      args = collapse{"+", x}
      mergeable{.table} with
         tr %
            args each arg ->
               th % engine.gen{arg}

   "wide [| x]"{engine, {=> x}} =
      args = collapse{"|", x}
      mergeable{.table} with
         tr %
            args each arg ->
               td % engine.gen{arg}

   "v <- value"{engine, {=> v, => value}} =
      result =
         match engine.gen{value}:
            ENode? x -> x
            x -> [% x]
      engine.setenv{raw{v}, result <<: value}
      ""
}

defaultDispatcher{ENode} =
   dispatch = Dispatcher{}
   items{defaultComponents{ENode}} each {spec, fn} ->
      dispatch.register with Spec{spec, fn}

   dispatch.register{Spec{spec, fn}} where

      filter{match node} =
         extract! #seq{"NL", *args} ->
            {args = args}
         else ->
            false

      spec = {"NL", #fn{filter}}

      fn{engine, {node => node and #seq{*elems}, => args}} =
         results = {}
         wide = node.width == .wide
         var last = null
         _gen = engine.gen.bind{engine}
         var i = -3

         add{addblank = true} =
            results.push with
               match last:
                  [div %]? or {block => true?} ->
                     last
                  != "" when wide ->
                     p % last
                  else ->
                     last
                  ;; [div %]? ->
                  ;;    last
                  ;; when wide and last !== "" ->
                  ;;    div % last
                  ;; else ->
                  ;;    last
            if addblank:
               results.push with
                  raw{elems[i]}
                  ;; elems[i].location.text{}

         var isFirst = true
         args each [_gen! match] ->
            do:
               i += 2
            x when isFirst ->
               isFirst = false
               last = x
            x when last and last.merge ->
               match last.merge{x}:
                  false? ->
                     add{}
                     last = x
                  newx ->
                     last = newx
            x ->
               add{}
               last = x
         i += 2
         if last:
            add{false}

         ;; if wide:
         ;;    then:
         ;;       div % results
         ;;    else:
         ;;       % results

         match results:
            {result} ->
               result
            else ->
               [% results] &: {block = Boolean! wide}

   dispatch




processDocuments{x, documents, maxiter = 10} =

   var forges = new Set{}
   deps = new Map{}

   populate{match node, documents, replace, path} =

      [redoc %]? ->
         {child} = node.children
         populate{child, newdocs, replace, path} where newdocs =
            match node.props.documents:
               Function? f -> f{documents}
               docs -> documents & docs

      [genfor %]? ->
         docname = node.props.document
         match documents[docname]:
            undefined? when node.props.important ->
               throw E.no_document{docname}
            false? ->
               ""
            {delay => true?} ->
               node
            doc ->
               doc.register.apply{doc, {path} ++ node.children}
               ""

      [genfrom %]? ->
         forges.add{{node, documents, replace, path}}
         "PLACEHOLDER"

      ENode? ->
         rval = ENode{tags, props, children} where
            tags = node.tags
            props = object with items{node.props} each {k, match v} ->
               [genfrom %]? ->
                  forges.add{{v, documents, replace, path ++ {k}}} where
                     replace{x} = rval.props[k] = x
                  {k, "PLACEHOLDER"}
               else ->
                  {k, v}
            children =
               enumerate{node.children} each {i, c} ->
                  populate{c, documents, replace, path ++ {i}} where
                     replace{x} = rval.children[i] = x
         rval

      Array? ->
         rval =
            enumerate{node} each {i, c} ->
               populate{c, documents, replace, path ++ {i}} where
                  replace{x} = rval[i] = x
         rval

      else ->
         node

   var res = populate{% x, documents, replace, {}} where
      replace{x} = res = x

   var niter = 0
   while forges.size != 0 and niter < maxiter:

      {_forges, forges} = {forges, new Set{}}
      niter += 1

      _forges each forge and {node, docs, replace, path} ->

         ;; Reset accessed/modified flags for all documents
         items{docs} each {_, doc} when doc._reset ->
            doc._reset{}

         ;; Execute generator, process new node, perform the replacement.
         replace with populate{newnode, docs, replace, path} where
            newnode = node.props.generate{docs}

         ;; For all modified documents, every process that accessed
         ;; them is put back in the queue for reprocessing
         items{docs} each {_, doc} when doc._modified ->
            [deps.get{doc} or {}] each
               forge -> forges.add{forge}
            deps.set{doc, {}}

         ;; For all documents it accessed, the current generator is
         ;; put in the dependencies for that document. Since we do this
         ;; after checking for modifications, a generator may modify
         ;; a document it accesses without causing an infinite loop.
         items{docs} each {_, doc} when doc._accessed ->
            if not deps.has{doc}: deps.set{doc, {}}
            deps.get{doc}.push with forge

   res.children[0] or res


QuaintFor{ENode} =
   Engine{defaultDispatcher{ENode}, null}

Quaint = QuaintFor{ENode}

create{evaluator} =
   Engine{defaultDispatcher{ENode}, evaluator}

defaultEngine = create{null}

toENode{text} =
   defaultEngine.run{text}

toHTML{toENode! match} =
   String? s -> s
   e -> e.toHTML{}

