
require:
   opg ->
      Source, Location
      transferLocation as [<<:]
   "./lang" ->
      parse
   "./tools" as tools ->
      makeExtractor
      raw, extract, collapse, statements
      shed, shedAll, shedIndent
      mergeable
   "./doc" ->
      SeqDocument

provide:
   parse
   Location, Source
   Engine
   create
   defaultEngine
   toENode, toHTML
   processDocuments
   tools




class Dispatcher:

   constructor{} =
      @dispatch = {}

   handler{node} =
      key = node.operator or ""
      if not key:
         console.error with
            "Node lacks an operator key. That may be indicative of a bug."
      match @dispatch[key]:
         undefined? ->
            false
         candidates ->
            candidates each c ->
               match node:
                  c! parts ->
                     return {parts, c}
                  else ->
                     pass
            false

   register{handler} =
      key = handler.operator
      l = [@dispatch[key] or= {}]
      l.unshift with handler

   clone{} =
      d = Dispatcher{}
      d.dispatch = object with items{@dispatch} each {key, l} ->
         {key, l.slice{0}}
      d


class Engine:

   constructor{Array! @plugins, @evaluator} =
      @dispatch = Dispatcher{}
      @plugins each p -> @plug{p}

   plug{p} =
      items{p.rules or {=}} each {rule, match} ->
         Function? handler ->
            @dispatch.register{Spec{rule, handler}}
         {rule, handler} ->
            @dispatch.register{Spec{rule, handler}}

   makeDocuments{} =
      acc = {=}
      @plugins each p when p.makeDocuments ->
         acc &: p.makeDocuments{}
      acc

   run{src, documents = {=}} =

      generated =
         match src:
            String? text ->
               return @run{Source{text, "<quaint>"}, documents}
            Source? src ->
               parsed = parse{src}
               @gen{parsed}
            node ->
               @gen{node}

      match documents:
         null? ->
            {generated, null}
         else ->
            docs = @makeDocuments{} & documents
            {processDocuments{generated, docs}, docs}


   .gen{match node} =
      
      #text{t} or #oper{t} ->
         l = node.location
         r = R.g"~|\\[\\~!@#$%^&*_\-+=<>/?;:.`|(){}\[\],.]"
         node.location.text{}.replace{r} with {match} ->
            "~" -> ""
            s -> s[1]

      #seq{*parts} ->
         result = match @dispatch.handler{node}:
            false? ->
               %
                  parts each part -> @gen{part}
            {values, handler} ->
               handler.gen{@, {node = node} & values}
         match result:
            ENode? {tags => {}, props => == {=}, => children} or Array? children
            \ when children.every{x -> String? x} ->
               r = children.join{""}
               if{result.block, % r, r}
            else ->
               result

   ;; register{spec, dispatcher} =
   ;;    @dispatch.register{Spec{spec, dispatcher}}
   ;;    @

   ;; registerAll{entries} =
   ;;    items{entries} each {spec, dispatcher} ->
   ;;       @register{spec, dispatcher}
   ;;    @

   eval{src} =
      @evaluator.eval{src}

   setenv{name, value} =
      @evaluator.setenv{name, value}


class Spec:
   constructor{makeExtractor! {@operator, @extractor}, @gen} =
      pass
   ":::project"{@extractor! match} =
      false? ->
         {false, null}
      values ->
         {true, values}


headerRule{level}{engine, {=> x}} =
   gx = engine.gen{x}
   rval =
      ^[S'h{level}'] %
         gx
         genfor %
            document = .sections
            {level, gx}
   rval &: {block = true}


basicPlugin = {

   makeDocuments{} = {
      sections = SeqDocument{}
   }

   regexps = {
   }

   rules = {

      "[[maybe x]]"{engine, {node => #seq{_, o, x, c, _}}} =
         beg = raw{o}.replace{"[", ""}
         middle = engine.gen{x}
         end = raw{c}.replace{"]", ""}
         ;; print {beg, middle, end, raw{middle}}
         res =
            if beg or end:
               % [beg, middle, end]
            else:
               middle
         res &: {block = middle.block}

      "{x}"{engine, {=> x}} =
         tools.code{engine, x}

      "{fn} : body"{engine, {=> fn, => body}} =
         try:
            f = engine.eval{fn.location}
            f{engine, body} or ""
         catch e:
            span.error % String{e}

      "_ x"{engine, {=> x}} =
         em % engine.gen{x}

      "__ x"{engine, {=> x}} =
         strong % engine.gen{x}

      "` x"{engine, {x => shed! x}} =
         code % raw{x}

      "label :: url"{engine, {=> label, url => shed! url}} =
         a %
            href = tools.rawOrCode{engine, url, {s} -> s.trim{}}
            engine.gen{label}

      "descr .. maybe contents"{engine, {=> descr, => contents}} =
         parts = raw{descr}.split{R"[ +]|(?=\.|#)"}
         var id = null
         tags = {}
         parts each
            "" ->
               pass
            R"^#(.*)"! {_, _id} ->
               id = _id
            tag ->
               tags.push with tag
         props = {=}
         if id: props.id = id
         ENode{tags, props, {engine.gen{shedIndent{contents}}}}

      "wide [= x]" = headerRule{1}
      "wide [== x]" = headerRule{2}
      "wide [=== x]" = headerRule{3}
      "wide [==== x]" = headerRule{4}
      "wide [===== x]" = headerRule{5}
      "wide [====== x]" = headerRule{6}

      "wide [# x]"{engine, {=> x}} =
         mergeable{.ol, li % engine.gen{x}}

      "wide [* x]"{engine, {=> x}} =
         mergeable{.ul, li % engine.gen{x}}

      "wide [+ x]"{engine, {=> x}} =
         args = collapse{"+", x}
         mergeable{.table} with
            tr %
               args each arg ->
                  th % engine.gen{arg}

      "wide [| x]"{engine, {=> x}} =
         args = collapse{"|", x}
         mergeable{.table} with
            tr %
               args each arg ->
                  td % engine.gen{arg}

      "v <- value"{engine, {=> v, => value}} =
         result =
            match engine.gen{value}:
               ENode? x -> x
               x -> [% x]
         engine.setenv{raw{v}, result <<: value}
         ""

      newlineRule = {spec, fn} where

         filter{match node} =
            extract! #seq{"NL", *args} ->
               {args = args}
            else ->
               false

         spec = {"NL", #fn{filter}}

         fn{engine, {node => node and #seq{*elems}, => args}} =
            results = {}
            wide = node.width == .wide
            var last = null
            _gen = engine.gen.bind{engine}
            var i = -3

            add{addblank = true} =
               results.push with
                  match last:
                     [div %]? or {block => true?} ->
                        last
                     != "" when wide ->
                        p % last
                     else ->
                        last
               if addblank:
                  results.push with
                     raw{elems[i]}

            var isFirst = true
            args each [_gen! match] ->
               do:
                  i += 2
               x when isFirst ->
                  isFirst = false
                  last = x
               x when last and last.merge ->
                  match last.merge{x}:
                     false? ->
                        add{}
                        last = x
                     newx ->
                        last = newx
               x ->
                  add{}
                  last = x
            i += 2
            if last:
               add{false}

            match results:
               {result} ->
                  result
               else ->
                  [% results] &: {block = Boolean! wide}

   }

}


processDocuments{x, documents, maxiter = 10} =

   var forges = new Set{}
   deps = new Map{}

   populate{match node, documents, replace, path} =

      [redoc %]? ->
         {child} = node.children
         populate{child, newdocs, replace, path} where newdocs =
            match node.props.documents:
               Function? f -> f{documents}
               docs -> documents & docs

      [genfor %]? ->
         docname = node.props.document
         match documents[docname]:
            undefined? when node.props.important ->
               throw E.no_document{docname}
            false? ->
               ""
            {delay => true?} ->
               node
            doc ->
               doc.register.apply{doc, {path} ++ node.children}
               ""

      [genfrom %]? ->
         forges.add{{node, documents, replace, path}}
         "PLACEHOLDER"

      ENode? ->
         rval = ENode{tags, props, children} where
            tags = node.tags
            props = object with items{node.props} each {k, match v} ->
               [genfrom %]? ->
                  forges.add{{v, documents, replace, path ++ {k}}} where
                     replace{x} = rval.props[k] = x
                  {k, "PLACEHOLDER"}
               else ->
                  {k, v}
            children =
               enumerate{node.children} each {i, c} ->
                  populate{c, documents, replace, path ++ {i}} where
                     replace{x} = rval.children[i] = x
         rval

      Array? ->
         rval =
            enumerate{node} each {i, c} ->
               populate{c, documents, replace, path ++ {i}} where
                  replace{x} = rval[i] = x
         rval

      else ->
         node

   var res = populate{% x, documents, replace, {}} where
      replace{x} = res = x

   var niter = 0
   while forges.size != 0 and niter < maxiter:

      {_forges, forges} = {forges, new Set{}}
      niter += 1

      _forges each forge and {node, docs, replace, path} ->

         ;; Reset accessed/modified flags for all documents
         items{docs} each {_, doc} when doc.resetFlags ->
            doc.resetFlags{}

         ;; Execute generator, process new node, perform the replacement.
         replace with populate{newnode, docs, replace, path} where
            newnode = node.props.generate{docs}

         ;; For all modified documents, every process that accessed
         ;; them is put back in the queue for reprocessing
         items{docs} each {_, doc} when doc.modified ->
            [deps.get{doc} or {}] each
               forge -> forges.add{forge}
            deps.set{doc, {}}

         ;; For all documents it accessed, the current generator is
         ;; put in the dependencies for that document. Since we do this
         ;; after checking for modifications, a generator may modify
         ;; a document it accesses without causing an infinite loop.
         items{docs} each {_, doc} when doc.accessed ->
            if not deps.has{doc}: deps.set{doc, {}}
            deps.get{doc}.push with forge

   res.children[0]


create{opts = {=}} =
   Engine{{basicPlugin, *[opts.plugins or {}]}, opts.evaluator}

defaultEngine = create{}

toENode{text} =
   {get node, docs} = defaultEngine.run{text}

toHTML{toENode! match} =
   String? s -> s
   e -> e.toHTML{}

