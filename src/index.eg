
require:
   opg ->
      Source, Location, transferLocation as [<<:]
      tokenize ->
         Tokenizer, indentTracker, inferLocation
      parse as _parse ->
         Parser, TokenGroups, PriorityOrder
   "./tools" as tools ->
      raw, extract, collapse, statements
      shed, shedAll, shedIndent
      mergeable

provide:
   Location, Source
   Quaint, QuaintFor
   create
   toENode, toHTML
   processDocuments
   tools


tok = Tokenizer with {

   regexps = {
      {.nl, " *(?:\n *)+"}
      {.ws, "[ ~]+"}
      {.op, "[!@#$%^&*_\\-+=<>/?;:.`|]+|[(){}\\[\\],.]"}
      {.word, "[^\n!@#$%^&*_\\-+=<>/?;:.`|\\[\\](){},. ~]+"}
      {.unknown, "."} ;; should never happen
   }

   post = {
      indentTracker{calcSize}
      inferLocation
      addDefaults
      tuckWhitespace
      classifyOperators
   } where

      calcSize{match token} =
         {type => .nl} ->
            {*, x} = token.token.split{"\n"}
            x.length
         else ->
            -1

      addDefaults{token} =
         token &: {wsb = 0, wsa = 0}

      tuckWhitespace{match tok, i, toks} =
         do:
            {prev, next} = {toks[i-1], toks[i+1]}
         {type => .ws, => token} ->
            prev.wsa and next.wsb = token.length
            next.tucked = tok
            {}
         {type => .op, token => "]" or "}" or ")"} ->
            prev.wsa and prev.wsb = 1
            {tok}
         {type => [.indent or .nl]} ->
            prev.wsa and prev.wsb = 1
            {tok}
         else ->
            {tok}

      classifyOperators{match tok} =
         do:
            tuck = tok.tucked
            delete tok.tucked
            sfx = this.sfx
            pad{tok} =
               if sfx:
                  padder = tuck or {
                     type = .sh_ws, token = ""
                     location = Location{
                        tok.location.source
                        tok.location.start
                        tok.location.start
                     }
                  }
                  {padder, tok}
               else:
                  {tok}

         {type => [.boundary or .ws or .indent]} ->
            this.sfx = false
            {tok}

         {type => .nl, => token} ->
            this.sfx = false
            if token.split{"\n"}.length <= 2:
               tok.type = .sh_nl
            {tok}

         {type => .dedent} ->
            this.sfx = true
            {tok}

         {type => .word} ->
            this.sfx = true
            pad{tok}

         {type => .op, => token, => wsb, => wsa} ->
            var never_sfx = false
            match tok.token:
               "(" or "[" or "{" ->
                  tok.type = .open
                  this.sfx = false
                  return pad{tok}
               ")" or "]" or "}" ->
                  tok.type = .close
                  this.sfx = true
                  return {tok}
               "," or ":" ->
                  never_sfx = true
               else ->
                  pass

            {tok.type, this.sfx, get} =
               match {sfx, wsb, wsa}:
                  {true?,  0  , 0}     -> {.sh_ifx, false, {tok}}
                  {true?,  > 0, > 0}   -> {.wi_ifx, false, {tok}}
                  {true?,  _  , 0}     -> {.sh_pfx, false, pad{tok}}
                  {true?,  0  , _}     -> {if{never_sfx, .wi_ifx, .sh_sfx}
                                           not never_sfx, {tok}}
                  {false?, 0  , 0}     -> {.sh_pfx, false,  {tok}}
                  {false?, > 0, > 0}   -> {.wi_pfx, false,  {tok}}
                  {false?, _  , 0}     -> {.sh_pfx, false,  {tok}}
                  {false?, 0  , _}     -> {.wi_pfx, false,  {tok}}

         else ->
            throw E.unknown_token_type{String{tok}}

}


prio = PriorityOrder{tokgrp, priorities} where

   tokgrp = TokenGroups with {
      sh_pfx = {.sh_pfx}
      sh_ifx = {.sh_ifx}
      sh_sfx = {.sh_sfx}
      wi_pfx = {.wi_pfx}
      wi_ifx = {.wi_ifx}
      wi_sfx = {.wi_sfx}
      sh_ws = {.sh_ws}
      ws = {.ws}
      sh_nl = {.sh_nl}
      nl = {.nl}
      indent = {.indent}
      dedent = {.dedent}
      openp = {"open ("}
      closep = {"close )"}
      opens = {"open ["}
      closes = {"close ]"}
      openb = {"open {"}
      closeb = {"close }"}
      period = {"sh_sfx ."}
      word = {.word}
      boundary = {.boundary}
   }

   MAX = Infinity

   priorities = {
      indent = {left = 280, right = 1}
      dedent = {left = 1  , right = MAX}
      opens  = {left = MAX, right = 2}
      closes = {left = 2  , right = MAX}
      openb  = {left = MAX, right = 3}
      closeb = {left = 3  , right = MAX}
      openp  = {left = MAX, right = 4}
      closep = {left = 4  , right = MAX}

      nl     = {left = 100, right = 100}
      sh_nl  = {left = 150, right = 150}

      wi_pfx = {left = MAX, right = 200}
      wi_ifx = {left = 201, right = 200}
      wi_sfx = {left = 201, right = MAX}
      ws     = {left = 250, right = 250}

      period = {left = 299, right = MAX}
      sh_pfx = {left = MAX, right = 300}
      sh_ifx = {left = 301, right = 300}
      sh_sfx = {left = 301, right = MAX}
      sh_ws  = {left = 350, right = 350}

      word   = {left = 1000, right = 1000}
      boundary = {left = -1, right = -1}
   }


finalize{match node} =
   {null?, mid and {=> token, => location}, null?} ->
      #text{token} <<: location

   {*parts} ->
      newparts = enumerate{parts} each {match i, part} ->
         match is part when i mod 2 == 0 ->
            null? ->
               #text{""} <<:
                  if [p = parts[i + 1]]:
                     p.location.at_start{}
                  else:
                     parts[i - 1].location.at_end{}
            else ->
               part
         else ->
            loc = Location{
               part.location.source
               if{let p = parts[i - 1], p.location.end, part.location.start}
               if{let p = parts[i + 1], p.location.start, part.location.end}
            }
            {let rval, width} = match part.type:
               .indent  -> {#oper{"I("}, .wide}
               .dedent  -> {#oper{")I"}, .wide}
               .sh_nl   -> {#oper{"NL"}, .short}
               .nl      -> {#oper{"NL"}, .wide}
               .sh_ws   -> {#oper{"J"}, .short}
               .ws      -> {#oper{"J"}, .wide}
               R"^sh_"? -> {#oper{part.token}, .short}
               R"^wi_"? -> {#oper{part.token}, .wide}
               else     -> {#oper{part.token}, .wide}
            rval.width = width
            rval <<: loc

      rval = #seq{*newparts} <<: Location{
         newparts[0].location.source
         newparts[0].location.start
         newparts[newparts.length - 1].location.end
      }
      rval &: {
         operator = newparts[1][1]
         width = newparts[1].width
      }
      adjust{rval}
   else ->
      throw E.syntax.unknown_node{node}


adjust{match node} =
   #seq{pre, inds and #oper{"I("}, mid, inde and #oper{")I"}, tail} ->
      findTarget{match x} =
         #seq{pre, #oper{"NL"}, *} ->
            findTarget{pre} or x
         else ->
            false
      target = findTarget{mid}
      if target:
         loc = pre.location.at_start{}
         target.location.start = loc.start
         node.location.start = loc.start
         inds.location = loc
         node[1] = #text{""} <<: loc
         target[1] = pre
      node
   else ->
      node


parser = Parser{tok, prio.getOrder{}, finalize}

parse{src} =
   parser.parse{src}


;; ============= ;;

parse_spec{match} =
   String? spec ->
      let ast = parse{Source{spec}}
      var top = null
      rval = helper{ast, {shed = true}} where helper{match, opts} =
         extract! #seq{"J", *tags, pattern} ->
            helper{pattern} with
               opts &
                  object with tags each #text{tag} -> {tag, true}
         ast when opts.wide ->
            #iswide{helper{ast, opts & {wide = false}}}
         ast when opts.short ->
            #isshort{helper{ast, opts & {short = false}}}
         #text{""} ->
            #eq{#text{""}}
         #text{v} ->
            #put{v, opts.maybe === true}
         #oper{op} ->
            #eq{#oper{op}}
         #seq{_, #oper{"["}, contents, #oper{"]"}, _} when opts.shed ->
            helper{contents, opts & {shed = false}}
         #seq{*args} and {=> operator} ->
            if [not top]:
               top = operator
            #seq{*[args each arg -> helper{arg, opts}]}
      {top, rval}
   {top, rval} ->
      {top, rval}


make_extractor{parse_spec! {top, spec}} =
   {top} with {node} ->
      helper{spec, node} where
         helper{match, node} =
            #iswide{subspec} ->
               [node.width == .wide] and
                  helper{subspec, node}
            #isshort{subspec} ->
               [node.width == .short] and
                  helper{subspec, node}
            #put{v, maybe} ->
               match node:
                  #text{""} when not maybe ->
                     false
                  else ->
                     {v => node}
            #eq{== node} ->
               {=}
            #eq ->
               false
            #seq{*subspecs} ->
               match node:
                  #seq{*args} when subspecs.length == args.length ->
                     rval = {=}
                     zip{subspecs, args} each {subspec, arg} ->
                        match helper{subspec, arg}:
                           false? ->
                              return false
                           vars ->
                              rval &: vars
                     rval
                  other ->
                     false
            #fn{f} ->
               f{node}



class Dispatcher:

   constructor{} =
      @dispatch = {}

   handler{node} =
      key = node.operator or ""
      if not key:
         console.error with
            "Node lacks an operator key. That may be indicative of a bug."
      match @dispatch[key]:
         undefined? ->
            false
         candidates ->
            candidates each c ->
               match node:
                  c! parts ->
                     return {parts, c}
                  else ->
                     pass
            false

   register{handler} =
      key = handler.operator
      l = [@dispatch[key] or= {}]
      l.unshift with handler

   clone{} =
      d = Dispatcher{}
      d.dispatch = object with items{@dispatch} each {key, l} ->
         {key, l.slice{0}}
      d


class Engine:

   constructor{@dispatch, @evaluator} =
      pass


   run{src, documents = undefined} =

      generated =
         match src:
            String? text ->
               @run{Source{text, "<quaint>"}, documents}
            Source? src ->
               parsed = parse{src}
               @gen{parsed}
            node ->
               @gen{node}

      match documents:
         undefined? ->
            processDocuments{generated, {=}}
         null? ->
            generated
         else ->
            processDocuments{generated, documents}


   .gen{match node} =
      #text{t} or #oper{t} ->
         l = node.location
         r = R.g"~|\\[\\~!@#$%^&*_\-+=<>/?;:.`|(){}\[\],.]"
         node.location.text{}.replace{r} with {match} ->
            "~" -> ""
            s -> s[1]
      #seq{*parts} ->
         result = match @dispatch.handler{node}:
            false? ->
               %
                  parts each part -> @gen{part}
            {values, handler} ->
               handler.gen{@, {node = node} & values}
         match result:
            ENode? {tags => {}, props => == {=}, => children} or Array? children
            \ when children.every{x -> String? x} ->
               r = children.join{""}
               if{result.block, % r, r}
            else ->
               result

   register{spec, dispatcher} =
      @dispatch.register{Spec{spec, dispatcher}}
      @

   registerAll{entries} =
      items{entries} each {spec, dispatcher} ->
         @register{spec, dispatcher}
      @

   eval{src} =
      @evaluator.eval{src}

   setenv{name, value} =
      @evaluator.setenv{name, value}


   getText{x} =
      raw{x}

   shed{x, n} =
      shed{x, n}

   shedAll{x} =
      shedAll{x}

   shedIndent{x} =
      shedIndent{x}

   getStatements{node} =
      statements{node}

   collapse{op, node} =
      collapse{op, node}


class Spec:
   constructor{make_extractor! {@operator, @extractor}, @gen} =
      pass
   ":::project"{@extractor! match} =
      false? ->
         {false, null}
      values ->
         {true, values}


defaultComponents{ENode} = {

   "[[maybe x]]"{engine, {node => #seq{_, o, x, c, _}}} =
      beg = raw{o}.replace{"[", ""}
      middle = engine.gen{x}
      end = raw{c}.replace{"]", ""}
      res =
         if beg and end:
            %
               raw{o}.replace{"[", ""}
               middle
               raw{c}.replace{"]", ""}
         else:
            middle
      res &: {block = middle.block}

   "{x}"{engine, {=> x}} =
      tools.code{engine, x}

   "{fn} : body"{engine, {=> fn, => body}} =
      try:
         f = engine.eval{fn.location}
         f{engine, body} or ""
      catch e:
         span.error % String{e}

   "_ x"{engine, {=> x}} =
      em % engine.gen{x}

   "__ x"{engine, {=> x}} =
      strong % engine.gen{x}

   "` x"{engine, {x => shed! x}} =
      code % raw{x}

   "label :: url"{engine, {=> label, url => shed! url}} =
      a %
         href = tools.rawOrCode{engine, url, {s} -> s.trim{}}
         engine.gen{label}

   "descr .. maybe contents"{engine, {=> descr, => contents}} =
      parts = raw{descr}.split{R"[ +]|(?=\.|#)"}
      var id = null
      tags = {}
      parts each
         "" ->
            pass
         R"^#(.*)"! {_, _id} ->
            id = _id
         tag ->
            tags.push with tag
      props = {=}
      if id: props.id = id
      ENode{tags, props, {engine.gen{shedIndent{contents}}}}

   "wide [= x]"{engine, {=> x}} =
      [h1 % engine.gen{x}] &: {block = true}
   "wide [== x]"{engine, {=> x}} =
      [h2 % engine.gen{x}] &: {block = true}
   "wide [=== x]"{engine, {=> x}} =
      [h3 % engine.gen{x}] &: {block = true}
   "wide [==== x]"{engine, {=> x}} =
      [h4 % engine.gen{x}] &: {block = true}
   "wide [===== x]"{engine, {=> x}} =
      [h5 % engine.gen{x}] &: {block = true}
   "wide [====== x]"{engine, {=> x}} =
      [h6 % engine.gen{x}] &: {block = true}

   "wide [# x]"{engine, {=> x}} =
      mergeable{.ol, li % engine.gen{x}}

   "wide [* x]"{engine, {=> x}} =
      mergeable{.ul, li % engine.gen{x}}

   "wide [+ x]"{engine, {=> x}} =
      args = collapse{"+", x}
      mergeable{.table} with
         tr %
            args each arg ->
               th % engine.gen{arg}

   "wide [| x]"{engine, {=> x}} =
      args = collapse{"|", x}
      mergeable{.table} with
         tr %
            args each arg ->
               td % engine.gen{arg}

   "v <- value"{engine, {=> v, => value}} =
      result =
         match engine.gen{value}:
            ENode? x -> x
            x -> [% x]
      engine.setenv{raw{v}, result <<: value}
      ""
}

defaultDispatcher{ENode} =
   dispatch = Dispatcher{}
   items{defaultComponents{ENode}} each {spec, fn} ->
      dispatch.register with Spec{spec, fn}

   dispatch.register{Spec{spec, fn}} where

      filter{match node} =
         extract! #seq{"NL", *args} ->
            {args = args}
         else ->
            false

      spec = {"NL", #fn{filter}}

      fn{engine, {node => node and #seq{*elems}, => args}} =
         results = {}
         wide = node.width == .wide
         var last = null
         _gen = engine.gen.bind{engine}
         var i = -3

         add{addblank = true} =
            results.push with
               match last:
                  [div %]? or {block => true?} ->
                     last
                  != "" when wide ->
                     p % last
                  else ->
                     last
                  ;; [div %]? ->
                  ;;    last
                  ;; when wide and last !== "" ->
                  ;;    div % last
                  ;; else ->
                  ;;    last
            if addblank:
               results.push with
                  raw{elems[i]}
                  ;; elems[i].location.text{}

         var isFirst = true
         args each [_gen! match] ->
            do:
               i += 2
            x when isFirst ->
               isFirst = false
               last = x
            x when last and last.merge ->
               match last.merge{x}:
                  false? ->
                     add{}
                     last = x
                  newx ->
                     last = newx
            x ->
               add{}
               last = x
         i += 2
         if last:
            add{false}

         ;; if wide:
         ;;    then:
         ;;       div % results
         ;;    else:
         ;;       % results

         match results:
            {result} ->
               result
            else ->
               [% results] &: {block = Boolean! wide}

   dispatch




processDocuments{x, documents, maxiter = 10} =

   var forges = new Set{}
   deps = new Map{}

   populate{match node, documents, replace, path} =

      [redoc %]? ->
         {child} = node.children
         populate{child, newdocs, replace, path} where newdocs =
            match node.props.documents:
               Function? f -> f{documents}
               docs -> documents & docs

      [genfor %]? ->
         docname = node.props.document
         match documents[docname]:
            undefined? when node.props.important ->
               throw E.no_document{docname}
            false? ->
               ""
            {delay => true?} ->
               node
            doc ->
               doc.register.apply{doc, {path} ++ node.children}
               ""

      [genfrom %]? ->
         forges.add{{node, documents, replace, path}}
         "PLACEHOLDER"

      ENode? ->
         rval = ENode{tags, props, children} where
            tags = node.tags
            props = object with items{node.props} each {k, match v} ->
               [genfrom %]? ->
                  forges.add{{v, documents, replace, path ++ {k}}} where
                     replace{x} = rval.props[k] = x
                  {k, "PLACEHOLDER"}
               else ->
                  {k, v}
            children =
               enumerate{node.children} each {i, c} ->
                  populate{c, documents, replace, path ++ {i}} where
                     replace{x} = rval.children[i] = x
         rval

      Array? ->
         rval =
            enumerate{node} each {i, c} ->
               populate{c, documents, replace, path ++ {i}} where
                  replace{x} = rval[i] = x
         rval

      else ->
         node

   var res = populate{% x, documents, replace, {}} where
      replace{x} = res = x

   var niter = 0
   while forges.size != 0 and niter < maxiter:

      {_forges, forges} = {forges, new Set{}}
      niter += 1

      _forges each forge and {node, docs, replace, path} ->

         ;; Reset accessed/modified flags for all documents
         items{docs} each {_, doc} when doc._reset ->
            doc._reset{}

         ;; Execute generator, process new node, perform the replacement.
         replace with populate{newnode, docs, replace, path} where
            newnode = node.props.generate{docs}

         ;; For all modified documents, every process that accessed
         ;; them is put back in the queue for reprocessing
         items{docs} each {_, doc} when doc._modified ->
            [deps.get{doc} or {}] each
               forge -> forges.add{forge}
            deps.set{doc, {}}

         ;; For all documents it accessed, the current generator is
         ;; put in the dependencies for that document. Since we do this
         ;; after checking for modifications, a generator may modify
         ;; a document it accesses without causing an infinite loop.
         items{docs} each {_, doc} when doc._accessed ->
            if not deps.has{doc}: deps.set{doc, {}}
            deps.get{doc}.push with forge

   res.children[0] or res


QuaintFor{ENode} =
   Engine{defaultDispatcher{ENode}, null}

Quaint = QuaintFor{ENode}

create{evaluator} =
   Engine{defaultDispatcher{ENode}, evaluator}

defaultEngine = create{null}

toENode{text} =
   defaultEngine.gen{text}

toHTML{text} =
   toENode{text}.toHTML{}

