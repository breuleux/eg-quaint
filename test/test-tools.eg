
requireMacros:
   "grey-mocha" ->
      describe, it, before, after
      assert, asserts

require:
   "grey-mocha"
   "../src/lang" ->
      parse
   "../src/tools" ->
      extractor, parseSpec
   "../src/doc" ->
      insertSorted, comparePaths


describe "misc":

   compare{match a, b} =
      > b -> 1
      < b -> -1
      else -> 0

   assertSorted{neighbours! xs each {x, y}} =
      assert x <= y

   it "insert sorted":
      xs = {}
      1..100 each i -> insertSorted{xs, Math.random{} * 10, compare}
      assertSorted{xs}
      ;; could fail if two random numbers come up the same. I'd like to see that happen
      assert xs.length == 100

   it "insert sorted (duplicates)":
      xs = consume{0..9}
      1..100 each i -> insertSorted{xs, [Math.random{} * 10] // 1, compare}
      assert xs == consume{0..9}

   asserts "compare paths":
      comparePaths{{1}, {2}} == -1
      comparePaths{{2}, {1}} == 1
      comparePaths{{1}, {1}} == 0
      comparePaths{{1, 2}, {1}} == 1
      comparePaths{{10}, {9}} == 1
      comparePaths{{93, 8, 4, 11}, {93, 9, 3, 10, 73}} == -1
      comparePaths{{93, 8, 4, 11}, {93, 8, 4, 11}} == 0




describe "extractor":

   it "simple extractor":
      ex = extractor{"\\x = \\y"}
      assert ex{parse{"hello = world"}} ==
         {x = #text{"hello"}, y = #text{"world"}}
      assert ex{parse{"hello=world"}} ==
         {x = #text{"hello"}, y = #text{"world"}}
      assert not ex{parse{"hello ="}}
      assert not ex{parse{"= world"}}
      assert not ex{parse{"hello ++ world"}}

   it "multiple matchers":
      ex = extractor{"\\x = \\y", "\\zz ++ \\qq"}
      assert ex{parse{"hello = world"}} ==
         {x = #text{"hello"}, y = #text{"world"}}
      assert ex{parse{"hello ++ world"}} ==
         {zz = #text{"hello"}, qq = #text{"world"}}

   it "optional arguments":
      ex = extractor{"\\maybe\\x = \\maybe\\y"}
      assert ex{parse{"hello = world"}} ==
         {x = #text{"hello"}, y = #text{"world"}}
      assert ex{parse{"hello="}} ==
         {x = #text{"hello"}, y = #text{""}}
      assert ex{parse{"=world"}} ==
         {x = #text{""}, y = #text{"world"}}

   it "literals":
      ex = extractor{"zazz :: \\x"}
      assert not ex{parse{"a :: b"}}
      assert ex{parse{"zazz :: b"}} == {x = #text{"b"}}

   moreSpecific{parseSpec! {_, _, s1}, parseSpec! {_, _, s2}} =
      s1 > s2

   asserts "specificity":
      moreSpecific{"x = y", "x = \\y"}
      moreSpecific{"x = y", "\\x = y"}
      moreSpecific{"x = y :: z", "x = y"}
      moreSpecific{"x = y", "\\x = \\y :: \\z"}
      moreSpecific{"\\x = \\y :: \\z", "\\x = \\y"}


   ;; it "simple extractor":
   ;;    ex = extractor{"x = y"}
   ;;    assert ex{parse{"hello = world"}} ==
   ;;       {x = #text{"hello"}, y = #text{"world"}}
   ;;    assert ex{parse{"hello=world"}} ==
   ;;       {x = #text{"hello"}, y = #text{"world"}}
   ;;    assert not ex{parse{"hello ="}}
   ;;    assert not ex{parse{"= world"}}
   ;;    assert not ex{parse{"hello ++ world"}}

   ;; it "multiple matchers":
   ;;    ex = extractor{"x = y", "zz ++ qq"}
   ;;    assert ex{parse{"hello = world"}} ==
   ;;       {x = #text{"hello"}, y = #text{"world"}}
   ;;    assert ex{parse{"hello ++ world"}} ==
   ;;       {zz = #text{"hello"}, qq = #text{"world"}}

   ;; it "optional arguments":
   ;;    ex = extractor{"[maybe x] = [maybe y]"}
   ;;    assert ex{parse{"hello = world"}} ==
   ;;       {x = #text{"hello"}, y = #text{"world"}}
   ;;    assert ex{parse{"hello="}} ==
   ;;       {x = #text{"hello"}, y = #text{""}}
   ;;    assert ex{parse{"=world"}} ==
   ;;       {x = #text{""}, y = #text{"world"}}


;; shed
